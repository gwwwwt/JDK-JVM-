### 关于构造函数和析构函数

> **前提: Stock是一个定义的类;**
>
> > **`Stock stock1 ("Nifty Foods", 10, 50.0)`**
> >
> > > **`初始化语句, stock1 指代Stock实例;`**
>
> > **`Stock stock1 = Stock("Nifty Foods", 10, 50.0)`**
> >
> > > **`这个根据编译器的不同可以有两种解释:`**
> > >
> > > > 1. **`和上面第一句一样, 按初始化语句理解; `**
> > >
> > > > 2. **`和下面的赋值语句一样, 创建了一个临时对象后复制到stock1中(这种解释比较少见, 个人测试是按第一种方式执行的)`**
>
> > **`Stock stock1; stock1 = Stock("Nifty Foods", 10, 50.0)`**
> >
> > > **`Stock stock1; 这一句是初始化语句, stock1此时指代调用Stock默认构造函数后的实例; `**
> > >
> > > **`stock1=Stock("Nifty Foods", 10, 50.0); 这一句不再是初始化语名, 而是一条赋值语名; 语义为通过Stock构造函数创建一个临时实例, 并将这个临时实例的内容能过赋值构造函数(或简单理解成字段复制)的方式赋值给stock1之后, 该临时实例会被调用析构函数之后销毁;`**
>
> **`关于new`**
>
> > **`在 C++ 和 Java 中都有 new 关键字, 但是它们的含义是不一样的: `**
> >
> > > **Java中, 调用构造方法创建类实例必须使用new, 而实例对象在堆内存中分配空间; **
> >
> > > **C++中, 调用构造函数可以不用使用new, 因为在C++中可以将类理解为结构体, 只不过由于类有访问限制的原因, 不能像结构体一样为每个字段赋值的方式来初始化(因为不能在类外访问private变量), 所以只能通过构造函数; **
> > >
> > > **构造函数创建类实例, `按个人理解, 认为是直接在当前栈桢中分配空间后访问; `**
> > >
> > > **而如果是 new Stock()这种方式创建类实例, `个人理解, new 标识Stock空间不在栈上分配, 而是在堆中分配; 所以new 只是用来限制空间分配的位置`**
> > >
> > > **所以, 在C++中, new不光可以标识构造函数, 如 new Stock(); 还可以标识其它类型, 比如 new int, new int[4], new {//结构体字段初始值}等,  来表示空间应该在堆中去分配; **
> > >
> > > **`而且, new 返回值为分配类型的指针, 此外释放分配空间的话, 还需要与 delete配合使用; `**



### 运算符重载

> **假设有一个`Salesperson`类, 并为它定义了一个 `operator+(...)` 成员函数, 以重载`+`运算符;**
>
> **district,sid, sara 都是`Salesperson`类对象, 那么 `district = sid + sara` 一行, 编译器会自动使用相应的运算符重载函数来替代成 `district = sid.operator+(sara);`**
>
> > **`需要注意的一点是, 并非只有成员函数能重载运算符, 非成员函数也可以, 参考下面的 "友元"说明; `**

#### 重载运算符限制

> 1. **重载后的运算符必须至少有一个操作数是用户定义的类型, 以防止用户为标准类型重载运算符;**
> 2. **使用运算符时不能违反运算符原来的句法规则, 如`+`需要两个操作数, 不能重载后变成一个操作数;  同样不能改变运算符的优先级;**
> 3. **不能创建新运算符;**
> 4. **不能重载特定的运算符, 如`sizeof`, `.`, `*`, `::`, `?`, `typeid`, `const_cast`, `dynamic_cast`等;**
> 5. **大多数运算符都可以通过成员或非成员函数进行重载, 但 `=`, `()`, `[]`,`->`几个符号只能用成员函数重载; **

### const 成员函数

> **如下语句: **
>
> ```c++
> //编译失败
> const Stock land = Stock("str", 10, 50.0);
> land.show();
> ```
>
> > **由于 land 被标识为 const Stock 常量, 而编译器无法通过show()成员函数的原型来确定它是否会修改Stock内部成员变量值, 从而违反const限制, 所以land.show()这一行无法通过编译; **
> >
> > **Stock内部可以声明 show() 函数不会修改Stock状态, 通过原型 `void show() const;` 实现**

### 友元

> `三种友元:`
>
> > **`友元函数`、`友元类`、`有元成员函数`**
> >
> > **`友元函数可以赋予函数与类的成员函数相同的权限; `**
> >
> > **//其它两种TODO...**
>
> **友元函数: **
>
> > **场景:**
> >
> > **以类`A`为例, 如果`A`中重载了 `operator*(double)` 方法, 那么编译器在遇到 `A*2.0`时, 会将其转换为`A.operator*(2.0)`;  但是根据乘号的语义, `A*2.0` 和 `2.0 * A` 的结果应该是相同的, 但 `2.0 * A` 却转换不成`A.operator*(2.0)`这样的形式, 因为此时 `A`是被调用对象,  `2.0`才是调用对象; **
> >
> > **可以定义非成员函数 `A operator*(double m, const A & a);` 来重载`*`号运算; 此时 `2.0 * A` 就会被转换成 `operator*(2.0, A)`** 
>
> > **问题:**
> >
> > **`如上, 通过定义 operator*(double, const A&); 的方式确定能解决 "2.0 * A"的转换问题; 但是它又引入了一个新的问题:`**
> >
> > > **`当想要在"*"号运算逻辑实现中, 返回 "2.0 * A.field" 的结果时, 非成员函数无法访问 A的成员变量的问题;`**
>
> > **解决方式:**
> >
> > **`将函数定义为A的友元, 这样函数将拥有和A的成员函数相同的访问权限; `**
> >
> > > **friend A operator*(double, const A &);**
> > >
> > > **`在声明中标识 friend 关键字, 在定义中不需要再添加 friend; `**
> >
> > > **`当然, 如果在 operator*(double, const A&); 的实现中不需要访问A的成员变量, 也可以不声明其为A的友元函数;`**

### 转换函数

#### 1. 其它类型转本类

> **如果类`Stonewt`中定义了如下构造函数:**
>
> > **Stonewt(double lbs);**
> >
> > > **可以理解成该构造函数将double类型转为了Stonewt类型;**
> > >
> > > ```c++
> > > Stonewt cat;
> > > cat = 19.6; //是合法的, 编译器会自动调用构造函数创建临时实例, 再将成员变量逐个复制到cat中
> > > ```
> > >
> > > > **`所以此时可以称 Stonewt(double); 这个函数为转换构造函数;`**
> > > >
> > > > **并且需要注意只能有一个参数, 多个参数的构造函数不可能是转换函数;**

#### 2. 本类转其它类

> **上面通过一个参数的构造函数, 编译器会自动调用该函数来将特定类型的值转为类实例;**
>
> **那怎么让本类实例转为其它类型;  `转换函数:`**
>
> > operator typeName(); 
>
> > 转换函数注意点: 
> >
> > 1. **`转换函数必须是类方法;`**
> > 2. **`转换函数不能指定返回类型; `**
> > 3. **`转换函数不能有参数;`**
>
> > 如类A中定义了一个成员函数： `operator double();`
> >
> > ```c++
> > A a;
> > double num = a; //这里编译器会自动调用 A.double() 之后将结果赋值组num;
> > ```

### 复制构造函数

> **StringBad为一个类**
>
> ```c++
> StringBad sports;
> StringBad sailer = sports; //这一行不是默认构造函数, 也不是其它构造函数, 这里调用了复制构造函数;
> ```
>
> > **复制构造函数: **
> >
> > > **StringBad sailer = sports; 等效于 StringBad sailer = StringBad(sports);**
> > >
> > > **构造函数原型为: StringBad(const StringBad&);**
> > >
> > > **在未明确定义复制构造函数的情况下, c++编译器会自动生成一个默认的复制构造函数; **
>
> **复制构造函数何时调用**
>
> > **新建一个对象, 并初始化为同类现有对象时, 会调用复制构造函数; **
> >
> > ***注意：也就是说复制构造函数用于初始化过程中（包括按值传递参数），而不是常规的赋值过程中；***
> >
> > > **`所以函数按值传递对象和按值返回对象时, 也都会调用复制构造函数`**
>
> **默认的复制构造函数的功能**
>
> > **逐个复制非静态成员(也叫浅复制), 复制的是成员的值;  如果成员也是类对象, 同样调用该成员类的复制构造函数进行复制;**
>
> **注意：**
>
> > **如果类中包含了使用new 初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据，而不是指针，也就是深度复制。浅复制仅浅浅的复制指针信息，而不会深入“挖掘”以复制指针引用的结构。**

### 赋值运算符

> **声明: `class_name & class_name::operator=(const class_name&)`**
>
> **`将已有的对象赋给另一个对象时, 将使用重载的赋值运算符；`**
>
> > ```c++
> > StringBad headline("Celebraty");
> > StringBad knot;
> > knot = headline; //会调用赋值运算符
> > 
> > StringBad metoo = knot; //初始化对象时,肯定会调用复制构造函数,但是否会调用赋值运算符, 依不同编译器决定
> > ```
>
> **默认赋值运算符逻辑**
>
> > **`与默认复制构造函数相同, 即浅复制;`**

### 关于复制构造函数和赋值运算符

> **假设 motto 是一个StringBad对象**
>
> > **StringBad ditto(motto); //调用复制构造函数初始化ditto对象**
> >
> > **StringBad *p = new StringBad(motto); //调用复制构造函数在堆中分配空间**
> >
> > **StringBad metto = motto;**
> >
> > **StringBad also = StringBad(motto);**
> >
> > > **对于上面最后两行，它们可能会`调用复制构造函数直接创建metto和also`，也可能`使用复制构造函数生成一个临时对象，再将临时对象的内容赋值给 metto 和 also（即调用赋值运算符函数）`，这取决于具体的实现。**

#### 包含类成员的类的逐成员复制

> **假设类于成员类型为String类或标准String类：**
>
> ```c++
> class Magazine
> {
>   private:
>   	String title;
>   	String publisher;
>   //...
> }
> ```
>
> > **String使用动态内存分配，定义了自己的复制构造函数和赋值运算符。那Magazine类是否需要编写复制构造函数和赋值运算符？不用的，至少对于Magazine类不用。默认的逐成员复制和赋值行为有一定的智能，如果将一个Magazine对象复制或赋值给另一个Managine对象，逐成员复制将使用成员类型定义的复制构造函数和赋值运算符，依此类推。**
> >
> > **如果Manazine中包含其它成员需要定义复制构造函数和赋值运算符，则Manazine需要定义特定的函数。**

### 特殊构造函数

> **在用户未定义的情况下, C++默认提供如下这些构造函数: **
>
> > + 默认构造函数
> > + 默认析构函数
> > + 复制构造函数
> > + 赋值运算符
> > + 地址运算符
> > + 移动构造函数(c++ 11)
> > + 移动赋值运算符(c++ 11)