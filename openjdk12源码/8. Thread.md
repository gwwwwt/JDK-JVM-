# Thread体系

```c++
// Class hierarchy
// - Thread
//   - JavaThread
//     - various subclasses eg CompilerThread, ServiceThread
//   - NonJavaThread
//     - NamedThread
//       - VMThread
//       - ConcurrentGCThread
//       - WorkerThread
//         - GangWorker
//         - GCTaskThread
//     - WatcherThread
//     - JfrThreadSampler
//
// All Thread subclasses must be either JavaThread or NonJavaThread.
// This means !t->is_Java_thread() iff t is a NonJavaThread, or t is
// a partially constructed/destroyed Thread.
```

## 父类ThreadShadow

> **ThreadShadow主要定义了`_pending_exception`字段**
>
> **源文件：src/hotspot/share/utilities/exceptions.hpp**

```c++
class ThreadShadow: public CHeapObj<mtThread> {
  friend class VMStructs;
  friend class JVMCIVMStructs;

 protected:
  oop  _pending_exception;                       // Thread has gc actions.
  const char* _exception_file;                   // file information for exception (debugging only)
  int         _exception_line;                   // line information for exception (debugging only)
  friend void check_ThreadShadow();              // checks _pending_exception offset

  // 定义这个virtual方法的唯一作用是, 需要ThreadShadow中包含一个vtable,
  // 这样vtable在Thread中就会处于偏移量为0的位置. 因为一些c++编译器, 在遇到ThreadShadow
  // 没有vtable, 而子类Thread中却有vtable时, 会将ThreadShadow放到vtable之后, 为了有一
  // 个统一的结构, 即vtable最好在偏移位置0处, 所以这里定义一个空实现的virtual方法. 
  virtual void unused_initial_virtual() { }

 public:
  oop  pending_exception() const                 { return _pending_exception; }
  bool has_pending_exception() const             { return _pending_exception != NULL; }
  const char* exception_file() const             { return _exception_file; }
  int  exception_line() const                    { return _exception_line; }

  // Code generation support
  static ByteSize pending_exception_offset() {
    return byte_offset_of(ThreadShadow, _pending_exception); 
  }

  // use THROW whenever possible!
  void set_pending_exception(oop exception, const char* file, int line);

  // use CLEAR_PENDING_EXCEPTION whenever possible!
  void clear_pending_exception();

  ThreadShadow() : _pending_exception(NULL),
                   _exception_file(NULL), _exception_line(0) {}
};
```



## Thread

> **源文件：src/hotspot/share/runtime/thread.hpp**
>
> > **Thread类定义太长，下面只贴一些认为重要的字段和方法。**

```c++
class Thread: public ThreadShadow {
    	
  static THREAD_LOCAL_DECL Thread* _thr_current; //THREAD_LOCAL_DECL宏 = __thread
  
  private:
  // Thread local data area available to the GC. The internal
  // structure and contents of this data area is GC-specific.
  // Only GC and GC barrier code should access this data area.
  GCThreadLocalData _gc_data;
  
  //...
}

```

