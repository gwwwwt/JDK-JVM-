# ParseArguments函数

> **源文件：java.c**

> **关于代码中局部变量mode，表示程序启动类型，可能的取值如下：**
>
> ```c
> enum LaunchMode {               // cf. sun.launcher.LauncherHelper
>     LM_UNKNOWN = 0,
>     LM_CLASS,
>     LM_JAR,
>     LM_MODULE,
>     LM_SOURCE
> };
> ```

```c
//依次解析命令行参数; 根据每个选项及参数, 进行添加option, 初始化全局变量或其它操作等
//会设置 pmode, pwhat, pret三个指针指向的值
static jboolean ParseArguments(int *pargc, char ***pargv, int *pmode, char **pwhat,
                               int *pret, const char *jrepath) {
    int argc = *pargc;
    char **argv = *pargv;
    int mode = LM_UNKNOWN; //程序启动类型
    char *arg;

    *pret = 0; //默认返回0

    //若 arg非null 且 arg第一个字符为'-', 则认为是选项, 进行处理
    while ((arg = *argv) != 0 && *arg == '-') {
        char *option = NULL;
        char *value = NULL;
        
        int kind = GetOpt(&argc, &argv, &option, &value); //参考下面第1节
      
        //若经过GetOpt调用后value非null, 表示选项有参数; 为null, 表示无参数
        jboolean has_arg = value != NULL && JLI_StrLen(value) > 0;
        jboolean has_arg_any_len = value != NULL;

        //--- Option to set main entry point
        if (JLI_StrCmp(arg, "-jar") == 0) {
            //对于-jar, 必须在后面跟着参数字符串, 若没有, 报错
            ARG_CHECK(argc, ARG_ERROR2, arg);
            //"-jar"选项会更新mode为 "LM_JAR"
            mode = checkMode(mode, LM_JAR, arg);
        } else if (JLI_StrCmp(arg, "--module") == 0 ||
                   JLI_StrCCmp(arg, "--module=") == 0 ||
                   JLI_StrCmp(arg, "-m") == 0) {
            //后面需要跟着参数, 即value为非Null且非空
            REPORT_ERROR (has_arg, ARG_ERROR5, arg);
            //添加"-Djdk.module.main=XXX" option
            SetMainModule(value);
            //更新mode为 LM_MODULE
            mode = checkMode(mode, LM_MODULE, arg);
            //若后面有参数, 则设置到 *pwhat中
            if (has_arg) {
               *pwhat = value; 
                break;
            }
        } else if (JLI_StrCmp(arg, "--source") == 0 ||
                   JLI_StrCCmp(arg, "--source=") == 0) {
            //后面需要参数
            REPORT_ERROR (has_arg, ARG_ERROR13, arg);
            mode = LM_SOURCE; //更新mode为 LM_SOURCE
          
            //添加"-Djdk.internal.javac.source=..." option
            if (has_arg) {
                const char *prop = "-Djdk.internal.javac.source=";
                size_t size = JLI_StrLen(prop) + JLI_StrLen(value) + 1;
                char *propValue = (char *)JLI_MemAlloc(size);
                JLI_Snprintf(propValue, size, "%s%s", prop, value);
                AddOption(propValue, NULL);
            }
        } else if (JLI_StrCmp(arg, "--class-path") == 0 ||
                   JLI_StrCCmp(arg, "--class-path=") == 0 ||
                   JLI_StrCmp(arg, "-classpath") == 0 ||
                   JLI_StrCmp(arg, "-cp") == 0) {
            REPORT_ERROR (has_arg_any_len, ARG_ERROR1, arg);
            //添加 "-Djava.class.path=..." option
            //SetClassPath参考《4. 通配符替换.md》
            SetClassPath(value);
            if (mode != LM_SOURCE) {
                mode = LM_CLASS; //更新mode
            }
        } else if (JLI_StrCmp(arg, "--list-modules") == 0) {
            listModules = JNI_TRUE;  //设置全局变量listModules
        } else if (JLI_StrCmp(arg, "--show-resolved-modules") == 0) {
            showResolvedModules = JNI_TRUE;
        } else if (JLI_StrCmp(arg, "--validate-modules") == 0) {
            AddOption("-Djdk.module.validation=true", NULL);
            validateModules = JNI_TRUE;
        } else if (JLI_StrCmp(arg, "--describe-module") == 0 ||
                   JLI_StrCCmp(arg, "--describe-module=") == 0 ||
                   JLI_StrCmp(arg, "-d") == 0) {
            REPORT_ERROR (has_arg_any_len, ARG_ERROR12, arg);
            describeModule = value;
          
        } else if (has_arg) { //不是以上的选项, 但后面跟随着非空参数
            if (kind == VM_LONG_OPTION) { //"--XXX=..."格式的选项, 直接添加到option中
                AddOption(option, NULL);
            } else if (kind == VM_LONG_OPTION_WITH_ARGUMENT) { //module相关选项
                AddLongFormOption(option, value); //添加不同格式的option
            }
          
        } else if (!has_arg && (JLI_StrCmp(arg, "--module-path") == 0 ||
                                JLI_StrCmp(arg, "-p") == 0 ||
                                JLI_StrCmp(arg, "--upgrade-module-path") == 0)) {
            //需要参数的情况下却未获取到参数, 直接报错
            REPORT_ERROR (has_arg, ARG_ERROR4, arg);

        } else if (!has_arg && (IsModuleOption(arg) || IsLongFormModuleOption(arg))) {
            REPORT_ERROR (has_arg, ARG_ERROR6, arg);
/*
 * The following cases will cause the argument parsing to stop
 */
        } else if (JLI_StrCmp(arg, "-help") == 0 ||
                   JLI_StrCmp(arg, "-h") == 0 ||
                   JLI_StrCmp(arg, "-?") == 0) {
            printUsage = JNI_TRUE;
            return JNI_TRUE;
        } else if (JLI_StrCmp(arg, "--help") == 0) {
            printUsage = JNI_TRUE;
            printTo = USE_STDOUT;
            return JNI_TRUE;
        } else if (JLI_StrCmp(arg, "-version") == 0) {
            printVersion = JNI_TRUE;
            return JNI_TRUE;
        } else if (JLI_StrCmp(arg, "--version") == 0) {
            printVersion = JNI_TRUE;
            printTo = USE_STDOUT;
            return JNI_TRUE;
        } else if (JLI_StrCmp(arg, "-showversion") == 0) {
            showVersion = JNI_TRUE;
        } else if (JLI_StrCmp(arg, "--show-version") == 0) {
            showVersion = JNI_TRUE;
            printTo = USE_STDOUT;
        } else if (JLI_StrCmp(arg, "--dry-run") == 0) {
            dryRun = JNI_TRUE;
        } else if (JLI_StrCmp(arg, "-X") == 0) {
            printXUsage = JNI_TRUE;
            return JNI_TRUE;
        } else if (JLI_StrCmp(arg, "--help-extra") == 0) {
            printXUsage = JNI_TRUE;
            printTo = USE_STDOUT;
            return JNI_TRUE;
/*
 * The following case checks for -XshowSettings OR -XshowSetting:SUBOPT.
 * In the latter case, any SUBOPT value not recognized will default to "all"
 */
        } else if (JLI_StrCmp(arg, "-XshowSettings") == 0 ||
                   JLI_StrCCmp(arg, "-XshowSettings:") == 0) {
            showSettings = arg;
        } else if (JLI_StrCmp(arg, "-Xdiag") == 0) {
            AddOption("-Dsun.java.launcher.diag=true", NULL);
        } else if (JLI_StrCmp(arg, "--show-module-resolution") == 0) {
            AddOption("-Djdk.module.showModuleResolution=true", NULL);
/*
 * The following case provide backward compatibility with old-style
 * command line options.
 */
        } else if (JLI_StrCmp(arg, "-fullversion") == 0) {
            JLI_ReportMessage("%s full version \"%s\"", _launcher_name, GetFullVersion());
            return JNI_FALSE;
        } else if (JLI_StrCmp(arg, "--full-version") == 0) {
            JLI_ShowMessage("%s %s", _launcher_name, GetFullVersion());
            return JNI_FALSE;
        } else if (JLI_StrCmp(arg, "-verbosegc") == 0) {
            AddOption("-verbose:gc", NULL);
        } else if (JLI_StrCmp(arg, "-t") == 0) {
            AddOption("-Xt", NULL);
        } else if (JLI_StrCmp(arg, "-tm") == 0) {
            AddOption("-Xtm", NULL);
        } else if (JLI_StrCmp(arg, "-debug") == 0) {
            AddOption("-Xdebug", NULL);
        } else if (JLI_StrCmp(arg, "-noclassgc") == 0) {
            AddOption("-Xnoclassgc", NULL);
        } else if (JLI_StrCmp(arg, "-Xfuture") == 0) {
            AddOption("-Xverify:all", NULL);
        } else if (JLI_StrCmp(arg, "-verify") == 0) {
            AddOption("-Xverify:all", NULL);
        } else if (JLI_StrCmp(arg, "-verifyremote") == 0) {
            AddOption("-Xverify:remote", NULL);
        } else if (JLI_StrCmp(arg, "-noverify") == 0) {
            AddOption("-Xverify:none", NULL);
        } else if (JLI_StrCCmp(arg, "-ss") == 0 ||
                   JLI_StrCCmp(arg, "-oss") == 0 ||
                   JLI_StrCCmp(arg, "-ms") == 0 ||
                   JLI_StrCCmp(arg, "-mx") == 0) {
            char *tmp = JLI_MemAlloc(JLI_StrLen(arg) + 6);
            sprintf(tmp, "-X%s", arg + 1); /* skip '-' */
            AddOption(tmp, NULL);
        } else if (JLI_StrCmp(arg, "-checksource") == 0 ||
                   JLI_StrCmp(arg, "-cs") == 0 ||
                   JLI_StrCmp(arg, "-noasyncgc") == 0) {
            /* No longer supported */
            JLI_ReportErrorMessage(ARG_WARN, arg);
        } else if (JLI_StrCCmp(arg, "-splash:") == 0) {
            ; /* Ignore machine independent options already handled */
        } else if (ProcessPlatformOption(arg)) {
            ; /* Processing of platform dependent options */
        } else {
            /* java.class.path set on the command line */
            if (JLI_StrCCmp(arg, "-Djava.class.path=") == 0) {
                _have_classpath = JNI_TRUE;
            }
            AddOption(arg, NULL);
        }
    }

    //如果前面的选项中未确定pwhat字符串, pwhat指向下一个非'-'开头的字符串
    if (*pwhat == NULL && --argc >= 0) {
        *pwhat = *argv++;
    }

    if (*pwhat == NULL) {
        //这里如果pwhat为null, 表示处理完'-'开始的选项之后, 后面没有多余的字符串了
        if (!listModules && !describeModule && !validateModules) {
            *pret = 1;
        }
    } else if (mode == LM_UNKNOWN) {
        /* default to LM_CLASS if -m, -jar and -cp options are
         * not specified */
        if (!_have_classpath) {
            SetClassPath("."); 
        }
        //根据文件后缀后确定是以java file还是以class文件启动
        mode = IsSourceFile(arg) ? LM_SOURCE : LM_CLASS;
    } else if (mode == LM_CLASS && IsSourceFile(arg)) {
        /* override LM_CLASS mode if given a source file */
        mode = LM_SOURCE;
    }

    if (mode == LM_SOURCE) {
        AddOption("--add-modules=ALL-DEFAULT", NULL);
        *pwhat = SOURCE_LAUNCHER_MAIN_ENTRY;
        // adjust (argc, argv) so that the name of the source file
        // is included in the args passed to the source launcher
        // main entry class
        *pargc = argc + 1;
        *pargv = argv - 1;
    } else {
        if (argc >= 0) {
            *pargc = argc;
            *pargv = argv;
        }
    }

    *pmode = mode;

    return JNI_TRUE;
}
```



## 1. GetOpt函数

> **获取选项与值字符串，对于命令行参数，大概有三种类型的参数格式：**
>
> 1. **`"--describe-module"`类型：\*poption对应的字符串就是"--describe-module"**
>
> 2. **`"-cp path"`类型：\*poption字符串为"-cp"，\*pvalue字符串为path**
>
>    > **有一个例外就是"-p"选项，如果是"-p"，则\*option字符串保存的是"--module-path"**
>
> 3. **`"--classpath=XXX"`类型：\*poption值为"--classpath=XXX"，\*pvalue值为"XXX"**

> **函数的副作用：参数pargc和pargv也会更新对应的源操作值**

> **函数返回结果为\*poption字符串对应的kind。**
>
> **kind的可能值如下：**
>
> ```c
> enum OptionKind {
>     LAUNCHER_OPTION = 0,
>     LAUNCHER_OPTION_WITH_ARGUMENT,
>     LAUNCHER_MAIN_OPTION,
>     VM_LONG_OPTION,
>     VM_LONG_OPTION_WITH_ARGUMENT,
>     VM_OPTION
> };
> ```

```c
/*
 * Gets the option, and its argument if the option has an argument.
 * It will update *pargc, **pargv to the next option.
 */
static int GetOpt(int *pargc, char ***pargv, char **poption, char **pvalue) {
    int argc = *pargc;
    char** argv = *pargv;
    char* arg = *argv; //获取当前字符串

    char* option = arg;
    char* value = NULL;
    char* equals = NULL;
    int kind = LAUNCHER_OPTION;
    jboolean has_arg = JNI_FALSE;

    /* 检查当前argv是否是一个带参数的选项, 需要同时满足两个条件: 
    	1. argc > 1
    	2. 当前 argv字符串以'-'开头且 (argv+1)字符串不是以'-'开头
    */
    has_arg = IsOptionWithArgument(argc, argv);

    argv++; --argc;
    
    /*
    launcher option: "-cp","-classpath","--class-path","--module","-m",
    									"--describe-module", "-d", "--source"
    				其中"--module", "-m" 还属于Launcher Main Option
    									
    module option: "--module-path", "-p", "--upgrade-module-path", "--add-module",
    								"--limit-modules", "--add-exports", "--add_opens",
    								"--add-reads", "--patch-module"
    */
    if (IsLauncherOption(arg)) {
        if (has_arg) {
            value = *argv;
            argv++; --argc;
        }
        kind = IsLauncherMainOption(arg) ? LAUNCHER_MAIN_OPTION
                                         : LAUNCHER_OPTION_WITH_ARGUMENT;
    } else if (IsModuleOption(arg)) {
        kind = VM_LONG_OPTION_WITH_ARGUMENT;
        if (has_arg) {
            value = *argv;
            argv++; --argc;
        }

        //如果为"-p", 设置option为 "--module-path"
        if (JLI_StrCmp(arg, "-p") == 0) {
            option = "--module-path";
        }
    } else if (JLI_StrCCmp(arg, "--") == 0 && (equals = JLI_StrChr(arg, '=')) != NULL) {
        //对于"--xxx="类型的选项, value取"="后的字符串
        value = equals+1;
        if (JLI_StrCCmp(arg, "--describe-module=") == 0 ||
            JLI_StrCCmp(arg, "--module=") == 0 ||
            JLI_StrCCmp(arg, "--class-path=") == 0||
            JLI_StrCCmp(arg, "--source=") == 0) {
            kind = LAUNCHER_OPTION_WITH_ARGUMENT;
        } else {
            kind = VM_LONG_OPTION;
        }
    }

    //--- 更新传入的参数对应的指针值
    *pargc = argc;
    *pargv = argv;
    *poption = option;
    *pvalue = value;
    return kind;
}
```

