# oop类

> **源码: oopsHierarchy.hpp**



## 1. 类型定义

```c++
typedef juint narrowOop; // Offset instead of address for an oop within a java object

typedef juint  narrowKlass; // If compressed klass pointers then use narrowKlass

typedef void* OopOrNarrowOopStar;

// 关于 markOopDesc类, 参考第2, 3节
typedef class  markOopDesc*  markOop;
```



## 2. oopDesc类

> **源码: oop.hpp**

> **`oopDesc`是objects classes的基类。 `{name}Desc`类描述了Java objects的格式，这样才能通过C++访问Java object的字段**
>
> **(see oopHierarchy for complete oop class hierarchy)**
>
> **此类以及它的子类都不能定义虚拟方法**

```c++
class oopDesc {
 	private:
  		volatile markOop _mark; //makrOop类型参考第3节Oop: typedef class markOopDesc* markOop;
  		union _metadata {
    			Klass*      _klass;
    			narrowKlass _compressed_klass; //typedef juint  narrowKlass; 4字节
  		} _metadata;
};
```



### 2.1 Klass类

> **源码: klass.hpp**

> **Klass类是Metadata的子类，Metadata又是MetaspaceObj的子类。"MetaspaceObj"中没有什么重要的字段，略过；**
>
> > **jvm使用oop/klass实现的原因是不想在每个object中都包含一个C++ vtbl指针。`这样，普通的oops就不必包含virtual函数，取而代之的是它们将所有的 'virtual function'调用都转发到它们的klass，klass有vtbl指针，可以进行虚函数C++ dispatch`**
>
> > **`Klass提供了如下信息:`**
> >
> > + **`language level class object (method dictionary ect.)`**
> > + **`provide vm dispatch behavior for the object`**
> >
> > **Both functions are combined into one C++ class**
>
> 
>
> ```c++
> class Metadata : public MetaspaceObj { // This is the base class for an internal Class related metadata
> 
>   public:
>       // ------ 这是不是 Java Object中的 hashCode() 的C++实现???
>   		int identity_hash()                { return (int)(uintptr_t)this; }
>   
>       // ---- 实现的父类方法
>   		virtual bool is_metadata()           const volatile { return true; }
>   		virtual bool is_klass()              const volatile { return false; }
>   		virtual bool is_method()             const volatile { return false; }
>   		virtual bool is_methodData()         const volatile { return false; }
>   		virtual bool is_constantPool()       const volatile { return false; }
>   		virtual bool is_methodCounters()     const volatile { return false; }
>   		virtual int  size()                  const = 0;
>   		virtual MetaspaceObj::Type type()    const = 0;
>   		virtual const char* internal_name()  const = 0;
>   		virtual void metaspace_pointers_do(MetaspaceClosure* iter) {}
> };
> ```

```c++
class Klass : public Metadata {

 	protected:
  		enum { _primary_super_limit = 8 };
  
      /* ----- The "layout helper" is a combined descriptor of object layout.
      对于非(实例或数组)的klasses,  _layout_helper 值为0. 
      对于实例对象, _layout_helper为正数时, 表示实例大小.
      对于数组对象, _layout_helper为负数, 4个字节中每个字节的含义如下: MSB:[tag, hsz, ebt, log2(esz)]:LSB
      		tag is 0x80 if the elements are oops, 0xC0 if non-oops
  			 	hsz is array header size in bytes (i.e., offset of first element)
    	  	ebt is the BasicType of the elements
  	    	esz is the element size in bytes
      */
  		jint        _layout_helper;

  		const KlassID _id; // Klass ID

  		Symbol* _name;// 类名;对于实例,格式如同java/lang/String; 对于数组, 格式如同 [Ljava/lang/String; ;对于其它类, 值为0

  		OopHandle _java_mirror; // Java类 java/lang/Class 是本Klass的 mirror

  		Klass*      _super;  // 父类

  		Klass* volatile _subklass; //第一子类, 没有的话为NULL; 可以通过_subklass->next_sibling() 来访问下一个子类
  		Klass* volatile _next_sibling; //结合上面的 _subklass 来理解

  		Klass*      _next_link; // 一个class loader加载的所有klass之间都通过 _next_link 字段来组成链表

			//加载本klass的 VM层面的ClassLoader表示; 它可以访问Java层面的 java.lang.ClassLoader类
  		ClassLoaderData* _class_loader_data; 

  		jint        _modifier_flags;  // 访问标志, 由 Class.getModifiers 使用
  		AccessFlags _access_flags;    // Access flags. The class/interface distinction is stored here.

      // --- 偏向锁实现
  		jlong    _last_biased_lock_bulk_revocation_time;
  		markOop  _prototype_header;   // Used when biased locking is both enabled and disabled for this type
 			jint     _biased_lock_revocation_count;

  		// ----- vtable长度
  		int _vtable_len;

	protected:
  		Klass(KlassID id);
  		Klass() : _id(KlassID(-1)) { assert(DumpSharedSpaces || UseSharedSpaces, "only for cds"); }
  //....
};

```



## 3. markOopDesc

> **源码: markOop.hpp**
>
> **markOopDesc 是 oopDesc的子类。描述一个对象的头部信息，按照oopDesc中 _mark的作用，其实用一个整数就可以，但JVM为了统一的使用 oop/klass 表示，就将 _mark定义成指向 markOopDesc类对象的指针，而内容则保存在markOopDesc中**

```c++

// The markOop describes the header of an object.
//
// Note that the mark is not a real oop but just a word.
// It is placed in the oop hierarchy for historical reasons.
//
// Bit-format of an object header (most significant first, big endian layout below):
//
//  32 bits:
//  --------
//             hash:25 ------------>| age:4    biased_lock:1 lock:2 (normal object)
//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)
//             size:32 ------------------------------------------>| (CMS free block)
//             PromotedObject*:29 ---------->| promo_bits:3 ----->| (CMS promoted object)
//
//  64 bits:
//  --------
//  unused:25 hash:31 -->| unused:1   age:4    biased_lock:1 lock:2 (normal object)
//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)
//  PromotedObject*:61 --------------------->| promo_bits:3 ----->| (CMS promoted object)
//  size:64 ----------------------------------------------------->| (CMS free block)
//
//  unused:25 hash:31 -->| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && normal object)
//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && biased object)
//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 ----->| (COOPs && CMS promoted object)
//  unused:21 size:35 -->| cms_free:1 unused:7 ------------------>| (COOPs && CMS free block)
//
//  - hash contains the identity hash value: largest value is
//    31 bits, see os::random().  Also, 64-bit vm's require
//    a hash value no bigger than 32 bits because they will not
//    properly generate a mask larger than that: see library_call.cpp
//    and c1_CodePatterns_sparc.cpp.
//
//  - the biased lock pattern is used to bias a lock toward a given
//    thread. When this pattern is set in the low three bits, the lock
//    is either biased toward a given thread or "anonymously" biased,
//    indicating that it is possible for it to be biased. When the
//    lock is biased toward a given thread, locking and unlocking can
//    be performed by that thread without using atomic operations.
//    When a lock's bias is revoked, it reverts back to the normal
//    locking scheme described below.
//
//    Note that we are overloading the meaning of the "unlocked" state
//    of the header. Because we steal a bit from the age we can
//    guarantee that the bias pattern will never be seen for a truly
//    unlocked object.
//
//    Note also that the biased state contains the age bits normally
//    contained in the object header. Large increases in scavenge
//    times were seen when these bits were absent and an arbitrary age
//    assigned to all biased objects, because they tended to consume a
//    significant fraction of the eden semispaces and were not
//    promoted promptly, causing an increase in the amount of copying
//    performed. The runtime system aligns all JavaThread* pointers to
//    a very large value (currently 128 bytes (32bVM) or 256 bytes (64bVM))
//    to make room for the age bits & the epoch bits (used in support of
//    biased locking), and for the CMS "freeness" bit in the 64bVM (+COOPs).
//
//    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread
//    [0           | epoch | age | 1 | 01]       lock is anonymously biased
//
//  - the two lock bits are used to describe three states: locked/unlocked and monitor.
//
//    [ptr             | 00]  locked             ptr points to real header on stack
//    [header      | 0 | 01]  unlocked           regular object header
//    [ptr             | 10]  monitor            inflated lock (header is wapped out)
//    [ptr             | 11]  marked             used by markSweep to mark an object
//                                               not valid at any other time
//
//    We assume that stack/thread pointers have the lowest two bits cleared.

class markOopDesc: public oopDesc {
	private:
  		uintptr_t value() const { return (uintptr_t) this; }
}
```



## 4. oop类

> **源码: oopsHierarchy.hpp**
>
> **oop可以理解成是 oopDesc的包装类**

```c++
class oop {
  		oopDesc* _o;

  		void register_oop();
  		void unregister_oop();
	public:
  		void set_obj(const void* p) {
    			raw_set_obj(p);
    			if (CheckUnhandledOops) register_oop();
  		}
  		void raw_set_obj(const void* p)     { _o = (oopDesc*)p; }

      // --- 构造和析构方法
  		oop()                               { set_obj(NULL); }
  		oop(const oop& o)                   { set_obj(o.obj()); }
  		oop(const volatile oop& o)          { set_obj(o.obj()); }
  		oop(const void* p)                  { set_obj(p); }
  		~oop()                              {
    			if (CheckUnhandledOops) unregister_oop();
  		}

  		oopDesc* obj()  const volatile      { return _o; }

  // General access
  oopDesc*  operator->() const        { return obj(); }
  bool operator==(void *p) const      { return obj() == p; }
  bool operator!=(void *p) const      { return obj() != p; }

  // Assignment
  oop& operator=(const oop& o)                            { _o = o.obj(); return *this; }
  volatile oop& operator=(const oop& o) volatile          { _o = o.obj(); return *this; }
  volatile oop& operator=(const volatile oop& o) volatile { _o = o.obj(); return *this; }
};
```



