# TSD & TLS

> **TSD & TLS目的：在一个进程中定义的全局或静态变量都是所有线程可见的，即每个线程共同操作一块存储区域。但是对于一个全局变量，每个线程对其的修改只在本线程内有效，各线程之间互不干扰。即每个线程虽然共享这个全局变量的名字，但这个变量的值就像只有在本线程内才会被修改和读取一样。**

## 线程特有数据（Thread-specific Data, TSD）

> **TSD由Posix线程库实现和维护。它提供了持久的每线程存储，每个线程都拥有一份对变量的拷贝。线程局部存储中的变量将一直存在，直到线程终止。**

> **应用：《1. 入口.md》3.3.2 Threads.create_vm方法**中的**`ThreadLocalStorage#init()`**调用

> **源文件：src/hotspot/share/runtime/threadLocalStorage.hpp **

```c++
class ThreadLocalStorage : AllStatic {
 // Exported API
 public:
  static Thread* thread(); // return current thread, if attached
  static void    set_thread(Thread* thread); // set current thread
  static void    init();
  static bool    is_initialized(); // can't use TLS prior to initialization
};
```

> **ThreadLocalStorage类实现：**
>
> **源文件：src/hotspot/share/runtime/threadLocalStorage.cpp**
>
> > **在ThreadLocalStorage.cpp中定义了静态变量 static pthread_key_t _thread_key**
> >
> > **在ThreadLocalStorage::init()中通过 pthread_key_create系统调用，为每个线程创建了一个线程特有数据，`即 每个线程都可以访问和设置 _thread_key 绑定的值，（通过pthread_getspecific和pthread_setspecific两个系统调用），但每个线程都只会相应的更改自己线程内部的值，从而实现线程局部存储。`**
>
> > **问题：为啥没有使用`__thread`关键字？？**

```c++
static pthread_key_t _thread_key;
static bool _initialized = false;

// Restore the thread pointer if the destructor is called. This is in case
// someone from JNI code sets up a destructor with pthread_key_create to run
// detachCurrentThread on thread death. Unless we restore the thread pointer we
// will hang or crash. When detachCurrentThread is called the key will be set
// to null and we will not be called again. If detachCurrentThread is never
// called we could loop forever depending on the pthread implementation.
extern "C" void restore_thread_pointer(void* p) {
  ThreadLocalStorage::set_thread((Thread*) p);
}

void ThreadLocalStorage::init() {
  assert(!_initialized, "initializing TLS more than once!");
  int rslt = pthread_key_create(&_thread_key, restore_thread_pointer);
  // If this assert fails we will get a recursive assertion failure
  // and not see the actual error message or get a hs_err file
  assert_status(rslt == 0, rslt, "pthread_key_create");
  _initialized = true;
}

bool ThreadLocalStorage::is_initialized() {
  return _initialized;
}

Thread* ThreadLocalStorage::thread() {
  // If this assert fails we will get a recursive assertion failure
  // and not see the actual error message or get a hs_err file.
  // Which most likely indicates we have taken an error path early in
  // the initialization process, which is using Thread::current without
  // checking TLS is initialized - see java.cpp vm_exit
  assert(_initialized, "TLS not initialized yet!");
  return (Thread*) pthread_getspecific(_thread_key); // may be NULL
}

void ThreadLocalStorage::set_thread(Thread* current) {
  assert(_initialized, "TLS not initialized yet!");
  int rslt = pthread_setspecific(_thread_key, current);
  assert_status(rslt == 0, rslt, "pthread_setspecific");
}
```



## 需要整理的

> https://blog.csdn.net/xiaokaige198747/article/details/81427534
>
> https://blog.csdn.net/yusiguyuan/article/details/14493499
>
> https://chao-tic.github.io/blog/2018/12/25/tls （重要）