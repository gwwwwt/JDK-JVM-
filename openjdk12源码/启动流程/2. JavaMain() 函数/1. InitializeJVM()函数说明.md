# InitializeJVM() 函数说明

> **源码: java.c**

> **调用链:  InitializeJVM ->JNI_CreateJavaVM -> JNI_CreateJavaVM_inner**

```c
//作用: 
//1. 初始化 Java Virtual Machine(用JavaVM结构体表示)
//2. 初始化完成后释放options数组
static jboolean InitializeJVM(JavaVM **pvm, JNIEnv **penv, InvocationFunctions *ifn)
{
    JavaVMInitArgs args;
    jint r;

    // -------------------- 用从命令行解析的JVM参数信息填充args结构体
    // -------------------- 这样后面的函数中就可以访问到命令行的JVM参数配置了
    memset(&args, 0, sizeof(args));
    args.version  = JNI_VERSION_1_2;
    args.nOptions = numOptions;
    args.options  = options;
    args.ignoreUnrecognized = JNI_FALSE;

		//log 略

    // ---- 核心: 调用了ifn->CreateJavaVM函数指针来完成创建JVM的工作
    r = ifn->CreateJavaVM(pvm, (void **)penv, &args);
  
    JLI_MemFree(options);
    return r == JNI_OK;
}
```



## 1. JNI_CreateJavaVM函数

> **"ifn->CreateJavaVM"指向的就是`JNI_CreateJavaVM`函数**
>
> **源码: jni.cpp**

```c++
_JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_CreateJavaVM(JavaVM **vm, void **penv, void *args) {
  jint result = JNI_ERR;
  result = JNI_CreateJavaVM_inner(vm, penv, args); //主要调用函数
  return result;
}
```



## 2. JNI_CreateJavaVM_inner函数

> **重要的函数调用: Threads::create_vm**

```c++
static jint JNI_CreateJavaVM_inner(JavaVM **vm, void **penv, void *args) {
  
  jint result = JNI_ERR;

  // 原英文注释: 下面的逻辑会用Atomic::xchg实现同步. 有些 Zero platforms使用
  // GCC内嵌的 __sync_lock_test_and_test来实现Atomic::xchg. 但是不同的平台
  // 对该指令的支持不同, 所以下面的 #if 主要是测试Atomic::xchg能否实现期望的功能
  /*
  Atomic::xchg(v1, p)方法大概逻辑是原子的实现如下序列:
  	{
  		v2 = *p; //取指针目标的原值
  		*p = v1; //将指针目标的值更新为参数
  		return v2; //返回原指针目标值
  	}
  */
#if defined(ZERO) && defined(ASSERT)
  {
    jint a = 0xcafebabe;
    //结果: b: 0xcafebabe; a: 0xdeadbeef 
    jint b = Atomic::xchg((jint) 0xdeadbeef, &a);
    void *c = &a;
    //结果: c: &b; d: &a
    void *d = Atomic::xchg(&b, &c);
    assert(a == (jint) 0xdeadbeef && b == (jint) 0xcafebabe, "Atomic::xchg() works");
    assert(c == &b && d == &a, "Atomic::xchg() works");
  }
#endif // ZERO && ASSERT

  //将vm_created设置为1, 如果 vm_created 之前已经是1, 直接退出
  if (Atomic::xchg(1, &vm_created) == 1) {
    return JNI_EEXIST;   
  }
  //将safe_to_recreate_vm更新为0, 如果它的值之前已经是0, 直接退出
  if (Atomic::xchg(0, &safe_to_recreate_vm) == 0) {
    return JNI_ERR; 
  }
  assert(vm_created == 1, "vm_created is true during the creation");

  /*
  成员变量作用, 原项注释: 如果在初始化过程中发生了一些特定错误的话, 并不会报错, 而是
  隔一段时间之后再尝试执行; 但是如果发生了重要错误的话, 可以将can_try_again设置为false,
  从而阻止再次执行初始化工作 */
  bool can_try_again = true;

  // --- ***核心调用, 参考《2. JavaMain() 函数/2-0 Threads::create_vm() - 创建VM.md》***
  result = Threads::create_vm((JavaVMInitArgs*) args, &can_try_again);
  
  if (result == JNI_OK) {
    JavaThread *thread = JavaThread::current();
    assert(!thread->has_pending_exception(), "should have returned not OK");
    /* thread is thread_in_vm here */
    *vm = (JavaVM *)(&main_vm);
    *(JNIEnv**)penv = thread->jni_environment();

#if INCLUDE_JVMCI
    if (EnableJVMCI) {
      if (UseJVMCICompiler) {
        // JVMCI is initialized on a CompilerThread
        if (BootstrapJVMCI) {
          JavaThread* THREAD = thread;
          JVMCICompiler* compiler = JVMCICompiler::instance(true, CATCH);
          compiler->bootstrap(THREAD);
          if (HAS_PENDING_EXCEPTION) {
            HandleMark hm;
            vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
          }
        }
      }
    }
#endif

    // Tracks the time application was running before GC
    RuntimeService::record_application_start();

    // Notify JVMTI
    if (JvmtiExport::should_post_thread_life()) {
       JvmtiExport::post_thread_start(thread);
    }

    post_thread_start_event(thread);

#ifndef PRODUCT
    if (ReplayCompiles) ciReplay::replay(thread);

    // Some platforms (like Win*) need a wrapper around these test
    // functions in order to properly handle error conditions.
    VMError::test_error_handler();
#endif

    // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving.
    ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native);
  } else {
    // If create_vm exits because of a pending exception, exit with that
    // exception.  In the future when we figure out how to reclaim memory,
    // we may be able to exit with JNI_ERR and allow the calling application
    // to continue.
    if (Universe::is_fully_initialized()) {
      // otherwise no pending exception possible - VM will already have aborted
      JavaThread* THREAD = JavaThread::current();
      if (HAS_PENDING_EXCEPTION) {
        HandleMark hm;
        vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
      }
    }

    if (can_try_again) {
      // reset safe_to_recreate_vm to 1 so that retrial would be possible
      safe_to_recreate_vm = 1;
    }

    // Creation failed. We must reset vm_created
    *vm = 0;
    *(JNIEnv**)penv = 0;
    // reset vm_created last to avoid race condition. Use OrderAccess to
    // control both compiler and architectural-based reordering.
    OrderAccess::release_store(&vm_created, 0);
  }

  // Flush stdout and stderr before exit.
  fflush(stdout);
  fflush(stderr);

  return result;

}
```

