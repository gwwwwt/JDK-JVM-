## 入口

> **文件：src/java.base/share/native/launcher/main.c**

```c++
//main入口, 以"java -version"为例, argc值为2, argv分别为java的完整路径和"-version"字符串
JNIEXPORT int main(int argc, char **argv)
{
    int margc;
    char** margv;
    int jargc;
    char** jargv;
    const jboolean const_javaw = JNI_FALSE;
  
    {
        int i, main_jargc, extra_jargc;
        JLI_List list;

        //0, 略
        main_jargc = (sizeof(const_jargs) / sizeof(char *)) > 1 
            ? sizeof(const_jargs) / sizeof(char *)
            : 0; // ignore the null terminator index

        //0, 略
        extra_jargc = (sizeof(const_extra_jargs) / sizeof(char *)) > 1
            ? sizeof(const_extra_jargs) / sizeof(char *)
            : 0; // ignore the null terminator index

        if (main_jargc > 0 && extra_jargc > 0) { // combine extra java args, 略...
            jargc = main_jargc + extra_jargc;
            list = JLI_List_new(jargc + 1);

            for (i = 0 ; i < extra_jargc; i++) {
                JLI_List_add(list, JLI_StringDup(const_extra_jargs[i]));
            }

            for (i = 0 ; i < main_jargc ; i++) {
                JLI_List_add(list, JLI_StringDup(const_jargs[i]));
            }

            // terminate the list
            JLI_List_add(list, NULL);
            jargv = list->elements;
         } else if (extra_jargc > 0) { // should never happen
            fprintf(stderr, "EXTRA_JAVA_ARGS defined without JAVA_ARGS");
            abort();
         } else { // no extra args, business as usual
            jargc = main_jargc;
            jargv = (char **) const_jargs;
         }
    }

    //初始化args.c中定义的一些static变量,大多为false
    JLI_InitArgProcessing(jargc > 0, const_disable_argfile); 
  
    {
        // accommodate the NULL at the end
        JLI_List args = JLI_List_new(argc + 1);
        int i = 0;

        // 首先在
        JLI_List_add(args, JLI_StringDup(argv[0]));
        // Append JDK_JAVA_OPTIONS
        if (JLI_AddArgsFromEnvVar(args, JDK_JAVA_OPTIONS)) {
            // JLI_SetTraceLauncher is not called yet
            // Show _JAVA_OPTIONS content along with JDK_JAVA_OPTIONS to aid diagnosis
            if (getenv(JLDEBUG_ENV_ENTRY)) {
                char *tmp = getenv("_JAVA_OPTIONS");
                if (NULL != tmp) {
                    JLI_ReportMessage(ARG_INFO_ENVVAR, "_JAVA_OPTIONS", tmp);
                }
            }
        }
        // Iterate the rest of command line
        for (i = 1; i < argc; i++) {
            JLI_List argsInFile = JLI_PreprocessArg(argv[i], JNI_TRUE);
            if (NULL == argsInFile) {
                JLI_List_add(args, JLI_StringDup(argv[i]));
            } else {
                int cnt, idx;
                cnt = argsInFile->size;
                for (idx = 0; idx < cnt; idx++) {
                    JLI_List_add(args, argsInFile->elements[idx]);
                }
                // Shallow free, we reuse the string to avoid copy
                JLI_MemFree(argsInFile->elements);
                JLI_MemFree(argsInFile);
            }
        }
        margc = args->size;
        // add the NULL pointer at argv[argc]
        JLI_List_add(args, NULL);
        margv = args->elements;
    }
  
    return JLI_Launch(margc, margv,
                   jargc, (const char**) jargv,
                   0, NULL,
                   VERSION_STRING,
                   DOT_VERSION,
                   (const_progname != NULL) ? const_progname : *margv,
                   (const_launcher != NULL) ? const_launcher : *margv,
                   jargc > 0,
                   const_cpwildcard, const_javaw, 0);
}
```



### JLI_List结构体说明

> **源文件：src/java.base/share/native/libjli/jli_util.h**
>
> > **当然函数实现在 jli_util.c 中**

```c
struct JLI_List_  // a dynamic list of char*; char*存储在elements中
{
    char **elements;
    size_t size;
    size_t capacity;
};
typedef struct JLI_List_ *JLI_List;

JNIEXPORT JLI_List JNICALL JLI_List_new(size_t capacity)
{
    JLI_List l = (JLI_List) JLI_MemAlloc(sizeof(struct JLI_List_)); //malloc调用
    l->capacity = capacity;
    
    //分配capacity个 (char*)空间, 所以elements是指向 (char*)的指针;
    l->elements = (char **) JLI_MemAlloc(capacity * sizeof(l->elements[0])); 
    l->size = 0;
    return l;
}

/*
复制以'\0'结尾的字符串, 实际包装的是 strdup() 系统调用, strdup()中会自动分配空间并复制, 返回的是 char*;
并且返回的 char* 可以使用 free() 释放空间;
*/
JNIEXPORT char * JNICALL JLI_StringDup(const char *s1)
{
    char *s = strdup(s1);
    if (s == NULL) {
        perror("strdup");
        exit(1);
    }
    return s;
}

//将 str 赋值给 elements[size]处,并递增size
JNIEXPORT void JNICALL JLI_List_add(JLI_List sl, char *str) 
{
    JLI_List_ensureCapacity(sl, sl->size+1);
    sl->elements[sl->size++] = str;
}

//往sl中添加 beg字符串的子字符串, 子字符串包含beg的前len个字符
void JLI_List_addSubstring(JLI_List sl, const char *beg, size_t len)
{
    char *str = (char *) JLI_MemAlloc(len+1);
    memcpy(str, beg, len);
    str[len] = '\0';
    JLI_List_ensureCapacity(sl, sl->size+1);
    sl->elements[sl->size++] = str;
}

//如果sl->capacity小于capacity参数, 扩容sl->elements
void JLI_List_ensureCapacity(JLI_List sl, size_t capacity)
{
    if (sl->capacity < capacity) {
        while (sl->capacity < capacity)
            sl->capacity *= 2;
      
        //realloc系统调用扩容elements
        sl->elements = JLI_MemRealloc(sl->elements, sl->capacity * sizeof(sl->elements[0]));
    }
}
```

