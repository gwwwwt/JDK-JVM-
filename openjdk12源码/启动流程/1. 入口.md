## 1. 入口 main.c#main

> **`提前说明：在下面的代码中，会省略一些无用的代码行，也可能会在if判断语句肯定为true或false的情况下，直接将if或else中的代码块提出来替换原来的整个if块。`**

> **文件：src/java.base/share/native/launcher/main.c**

```c++
//working directory为: 某个项目的target/classes目录
//main入口, 以"java idea.NotifyDemo"为例, argc值为2, argv分别为java的完整路径和"idea.NotifyDemo"字符串
JNIEXPORT int main(int argc, char **argv)
{
    int margc;
    char** margv;
    int jargc;
    char** jargv;
    const jboolean const_javaw = JNI_FALSE;
  
    {
        int i, main_jargc, extra_jargc;
        JLI_List list;

        //0, 略
        main_jargc = (sizeof(const_jargs) / sizeof(char *)) > 1 
            ? sizeof(const_jargs) / sizeof(char *)
            : 0; // ignore the null terminator index

        //0, 略
        extra_jargc = (sizeof(const_extra_jargs) / sizeof(char *)) > 1
            ? sizeof(const_extra_jargs) / sizeof(char *)
            : 0; // ignore the null terminator index

        if (main_jargc > 0 && extra_jargc > 0) { // combine extra java args, 略...
            jargc = main_jargc + extra_jargc;
            list = JLI_List_new(jargc + 1);

            for (i = 0 ; i < extra_jargc; i++) {
                JLI_List_add(list, JLI_StringDup(const_extra_jargs[i]));
            }

            for (i = 0 ; i < main_jargc ; i++) {
                JLI_List_add(list, JLI_StringDup(const_jargs[i]));
            }

            // terminate the list
            JLI_List_add(list, NULL);
            jargv = list->elements;
         } else if (extra_jargc > 0) { // should never happen
            fprintf(stderr, "EXTRA_JAVA_ARGS defined without JAVA_ARGS");
            abort();
         } else { // no extra args, business as usual
            jargc = main_jargc;
            jargv = (char **) const_jargs;
         }
    }

    //初始化args.c中定义的一些static变量,大多为false
    JLI_InitArgProcessing(jargc > 0, const_disable_argfile); 
  
    {
        // accommodate the NULL at the end
        JLI_List args = JLI_List_new(argc + 1);
        int i = 0;

        // 首先在args复制java可执行程序的绝对路径添加到args中
        JLI_List_add(args, JLI_StringDup(argv[0]));
        
        // 在环境变量中查询是否包含 "JDK_JAVA_OPTIONS", 如果有, 则将这些选项附加到args中;
        // 默认是没有这个环境变量的, 所以略过
        if (JLI_AddArgsFromEnvVar(args, JDK_JAVA_OPTIONS)) {
            
            if (getenv(JLDEBUG_ENV_ENTRY)) {
                char *tmp = getenv("_JAVA_OPTIONS");
                if (NULL != tmp) {
                    JLI_ReportMessage(ARG_INFO_ENVVAR, "_JAVA_OPTIONS", tmp);
                }
            }
        }
       
        // 从第二个参数开始遍历并附加到args中
        for (i = 1; i < argc; i++) {
            JLI_List argsInFile = JLI_PreprocessArg(argv[i], JNI_TRUE);
            if (NULL == argsInFile) {
                JLI_List_add(args, JLI_StringDup(argv[i]));
            } else {
                int cnt, idx;
                cnt = argsInFile->size;
                for (idx = 0; idx < cnt; idx++) {
                    JLI_List_add(args, argsInFile->elements[idx]);
                }
                // Shallow free, we reuse the string to avoid copy
                JLI_MemFree(argsInFile->elements);
                JLI_MemFree(argsInFile);
            }
        }
      
        //margc变量值是(java idea.NotifyDemo)命令参数数量和JDK_JAVA_OPTIONS环境变量的选项数量之和
        //由于本机没有该环境变量, 所以这里 margc 和 argc参数相同
        margc = args->size; 

        JLI_List_add(args, NULL); //JLI_List最后一定会附加一个NULL
      
        //margv是 char*数组, 字符串内容分别为("java绝对路径", "idea.NotifyDemo", NULL)
        margv = args->elements; 
    }
  
    //接着调用JLI_Launch函数
    return JLI_Launch(margc, margv,
                   jargc /*值为0*/, (const char**) jargv /*为NULL*/,
                   0, NULL,
                   VERSION_STRING, /*"12-internal+0-adhoc.gwwwwt.jdk12"*/
                   DOT_VERSION, /*"0.0"*/
                   (const_progname != NULL) ? const_progname /*"java"*/ : *margv,
                   (const_launcher != NULL) ? const_launcher /*"openjdk"*/: *margv,
                   jargc > 0/*false*/, const_cpwildcard /*true*/, const_javaw/*false*/, 0);
}
```



### 1.1 JLI_List结构体说明

> **源文件：src/java.base/share/native/libjli/jli_util.h**
>
> > **当然函数实现在 jli_util.c 中**

```c
struct JLI_List_  // a dynamic list of char*; char*存储在elements中
{
    char **elements;
    size_t size;
    size_t capacity;
};
typedef struct JLI_List_ *JLI_List;

JNIEXPORT JLI_List JNICALL JLI_List_new(size_t capacity)
{
    JLI_List l = (JLI_List) JLI_MemAlloc(sizeof(struct JLI_List_)); //malloc调用
    l->capacity = capacity;
    
    //分配capacity个 (char*)空间, 所以elements是指向 (char*)的指针;
    l->elements = (char **) JLI_MemAlloc(capacity * sizeof(l->elements[0])); 
    l->size = 0;
    return l;
}

/*
复制以'\0'结尾的字符串, 实际包装的是 strdup() 系统调用, strdup()中会自动分配空间并复制, 返回的是 char*;
并且返回的 char* 可以使用 free() 释放空间;
*/
JNIEXPORT char * JNICALL JLI_StringDup(const char *s1)
{
    char *s = strdup(s1);
    if (s == NULL) {
        perror("strdup");
        exit(1);
    }
    return s;
}

//将 str 赋值给 elements[size]处,并递增size
JNIEXPORT void JNICALL JLI_List_add(JLI_List sl, char *str) 
{
    JLI_List_ensureCapacity(sl, sl->size+1);
    sl->elements[sl->size++] = str;
}

//往sl中添加 beg字符串的子字符串, 子字符串包含beg的前len个字符
void JLI_List_addSubstring(JLI_List sl, const char *beg, size_t len)
{
    char *str = (char *) JLI_MemAlloc(len+1);
    memcpy(str, beg, len);
    str[len] = '\0';
    JLI_List_ensureCapacity(sl, sl->size+1);
    sl->elements[sl->size++] = str;
}

//如果sl->capacity小于capacity参数, 扩容sl->elements
void JLI_List_ensureCapacity(JLI_List sl, size_t capacity)
{
    if (sl->capacity < capacity) {
        while (sl->capacity < capacity)
            sl->capacity *= 2;
      
        //realloc系统调用扩容elements
        sl->elements = JLI_MemRealloc(sl->elements, sl->capacity * sizeof(sl->elements[0]));
    }
}
```



## 2. JLI_Launch函数

> 源文件：src/java.base/share/native/libjli/java.c
>
> > **关于传入的参数参考上面main()函数的说明。**
>
> > 此函数主要的步骤为：
> >
> > 1. **根据参数初始化一些静态变量值**
> >
> > 2. **CreateExecutionEnvironment()初始化jvmpath、jrepath等路径信息**
> >
> > 3. **LoadJavaVM()获取jni.cpp中定义的函数指针**
> >
> >    > 执行函数后, ifn中的三个函数指针如下:
> >    > **`CreateJavaVM: JNI_CreateJavaVM (jni.cpp)`**
> >    > **`GetDefaultJavaVMInitArgs: JNI_GetDefaultJavaVMInitArgs (jni.cpp)`**
> >    > **`GetCreatedJavaVMs: JNI_GetCreatedJavaVMs (jni.cpp)`**
> >
> > 4. **parseArgements()、SetJavaCommandLineProp()等函数解析参数**
> >
> > 5. **JVMInit()在新线程中调用第3步中获取的函数**
> >
> >    > **新线程中会调用 JavaMain 函数入口（即正式进入jvm逻辑）**

```c++
JNIEXPORT int JNICALL JLI_Launch(int argc, char ** argv,              /* main argc, argv */
        int jargc, const char** jargv,          /* java args */
        int appclassc, const char** appclassv,  /* app classpath */
        const char* fullversion,                /* full version defined */
        const char* dotversion,                 /* UNUSED dot version defined */
        const char* pname,                      /* program name */
        const char* lname,                      /* launcher name */
        jboolean javaargs,                      /* JAVA_ARGS */
        jboolean cpwildcard,                    /* classpath wildcard*/
        jboolean javaw,                         /* windows-only javaw */
        jint ergo                               /* unused */
)
{
    int mode = LM_UNKNOWN; //0
    char *what = NULL;
    char *main_class = NULL;
    int ret;
    InvocationFunctions ifn;
    jlong start, end;
    char jvmpath[MAXPATHLEN];
    char jrepath[MAXPATHLEN];
    char jvmcfg[MAXPATHLEN];

    //初始化java.c中定义的静态变量
    _fVersion = fullversion;  //"12-internal+0-adhoc.gwwwwt.jdk12"
    _launcher_name = lname;   //"openjdk"
    _program_name = pname;    //"java"
    _is_java_args = javaargs; //0(false)
    _wc_enabled = cpwildcard; //1(true)

    //设置jli_util.c中定义的静态变量 static jboolean _launcher_debug = JNI_FALSE;
    InitLauncher(javaw); 
    DumpState(); //由于 _launcher_debug 值设置为false, 所以这里不输出 launcher信息(也就是上面初始化的静态信息)
  
    SelectVersion(argc, argv, &main_class);

    //获取各种运行环境路径, 包括jrepath jvmpath jvmcfg
    /*
    以本机的环境来说, 获取得到的各种路径如下:
    jrepath: "/Users/gwwwwt/jvm/jdk12/build/macosx-x86_64-server-fastdebug/jdk"
    jvmpath: "/Users/gwwwwt/jvm/jdk12/build/macosx-x86_64-server-fastdebug/jdk/lib/server/libjvm.dylib"
    jvmcfg: "/Users/gwwwwt/jvm/jdk12/build/macosx-x86_64-server-fastdebug/jdk/lib/jvm.cfg"
    */
    CreateExecutionEnvironment(&argc, &argv,
                               jrepath, sizeof(jrepath),
                               jvmpath, sizeof(jvmpath),
                               jvmcfg,  sizeof(jvmcfg));

    if (!IsJavaArgs()) {
        SetJvmEnvironment(argc,argv);
    }

    ifn.CreateJavaVM = 0;
    ifn.GetDefaultJavaVMInitArgs = 0;

    /*
    加载 "lib/server/libjvm.dylib" 动态链接库, 再从加载的库中查询相应的函数地址, 相关指针保存在ifn结构体中;
    	ifn结构体
    	typedef struct {
    		CreateJavaVM_t CreateJavaVM;
    		GetDefaultJavaVMInitArgs_t GetDefaultJavaVMInitArgs;
    		GetCreatedJavaVMs_t GetCreatedJavaVMs;
			} InvocationFunctions;
    
    执行函数后, ifn中的三个函数指针如下:
    CreateJavaVM: JNI_CreateJavaVM (jni.cpp)
    GetDefaultJavaVMInitArgs: JNI_GetDefaultJavaVMInitArgs (jni.cpp)
    GetCreatedJavaVMs: JNI_GetCreatedJavaVMs (jni.cpp)
    */
    if (!LoadJavaVM(jvmpath, &ifn)) {
        return(6);
    }

    ++argv; //argv指向命令行第二个参数
    --argc; //argc自减1
        
  	/*
    如果设置了CLASSPATH环境变量, 则附加-Djava.class.path=%s选项,    
    当然如果在CLASSPATH中包含 '*'也是需要展开后再附加
    */
  	char* cpath = getenv("CLASSPATH");
  	if (cpath != NULL) { SetClassPath(cpath);}
  

    //解析参数, 包括-jar 或 -classpath等选项, 并做出相应处理
    if (!ParseArguments(&argc, &argv, &mode, &what, &ret, jrepath)) {
        return(ret);
    }

    if (mode == LM_JAR) {
        SetClassPath(what);     /* Override class path */
    }

    // 处理 -DXXX 类似的属性设置
    SetJavaCommandLineProp(what, argc, argv);

    /* Set the -Dsun.java.launcher pseudo property */
    SetJavaLauncherProp();

    /* set the -Dsun.java.launcher.* platform properties */
    SetJavaLauncherPlatformProps();

    //注意, 经过上面的处理, argc值已经变为了0, 而argv也只有一个NULL指针;
    //此时, what中存储的是 idea.NotifyDemo; mode值为1, ret为0;
    return JVMInit(&ifn, threadStackSize, argc, argv, mode, what, ret);
}
```

### 2.1 CreateExecutionEnvironment函数

> 源文件：src/java.base/macosx/native/libjli/java_md_macosx.m
>
> > **在函数最后，调用了MacOSXStartup()函数，根据注释信息，由于Mac OS X系统的原因，需要在主线程中启动Cocoa event loop。JVM干了件啥事，它在MAcOSXStartup()函数中新启动了一个线程，在新线程里`丧心病狂的通过dlsym()查找到了本Note一开始的main()函数地址后，重新跑了一遍main()函数。`之后main线程则处理Cocoa event loop相关，新线程执行完CreateExecutionEnvironment()函数后，回到JLI_Launch()函数继续执行。**
> >
> > **导致的现象就是在调试时，开始在Thread-1(即开始的main线程)中的main()函数体中打断点后，继续执行的话会发现出现一个 Thread-2线程也执行到了main()函数的对应位置后暂停了，悉知。**
>
> > **注意：这里启动了一个新线程。**

```c
void CreateExecutionEnvironment(int *pargc, char ***pargv,
                           char jrepath[], jint so_jrepath,
                           char jvmpath[], jint so_jvmpath,
                           char jvmcfg[],  jint so_jvmcfg) {
    jboolean jvmpathExists;

    // 设置定义的静态变量 static char *execname 为java可执行文件的绝对路径;
    SetExecname(*pargv);

    char * jvmtype    = NULL;
    int  argc         = *pargc; //命令行参数个数
    char **argv       = *pargv; //命令行参数字符串数组
 
    /*
    获取jre path并存储到 jrepath字符数组中;
    
    以本机环境为例, *execname中的路径, 也就是java完整路径为
    	"/Users/gwwwwt/jvm/jdk12/build/macosx-x86_64-server-fastdebug/jdk/bin/java"
    	
    GetJREPath函数会先在路径中搜索 "/bin/java"子字符串, 如果包含该子字符串, 则删除该子字符串, 即获取到
    	"/Users/gwwwwt/jvm/jdk12/build/macosx-x86_64-server-fastdebug/jdk"结果,
    	
    之后验证在上面返回的结果目录中是否有 "lib/libjava.dylib" 这个动态链接库文件, 如果有, 并且可访问这个文件, 则表示
    上面的结果是一个合法的 jre path, 
    
    即 GetJREPath如果运行正常, 返回后 jrepath数组中就保存了合适的 jre path结果
    */
    if (!GetJREPath(jrepath, so_jrepath, JNI_FALSE) ) {
        JLI_ReportErrorMessage(JRE_ERROR1);
        exit(2);
    }
  
    //jvmcfg数组中结果: "/Users/gwwwwt/jvm/jdk12/build/macosx-x86_64-server-fastdebug/jdk/lib/jvm.cfg"
    JLI_Snprintf(jvmcfg, so_jvmcfg, "%s%slib%sjvm.cfg", jrepath, FILESEP, FILESEP);
    
    /*
    读取 jvmcfg指定的配置文件, 将信息保存到 static struct vmdesc *knownVMs 中; 
    
    配置文件中的每一行都对应一个 vmdesc结构体;
    	struct vmdesc {
        char *name;
    		int flag;
    		char *alias;
    		char *server_class;
			};
			
   	本机的jvmcfg文件内容为两行:
   		-server KNOWN
			-client IGNORE
			
		解析结果就是
    knownVMs[0].name="-server"; knowVMs[0].flag = vmdesc_flag.VM_KNOWN(枚举值为0)
    knownVMs[1].name="-client"; knowVMs[1].flag = vmdesc_flag.VM_IGNORE(枚举值为5)
    */
    if (ReadKnownVMs(jvmcfg, JNI_FALSE) < 1) {
        JLI_ReportErrorMessage(CFG_ERROR7);
        exit(1);
    }

    jvmpath[0] = '\0';
  
    //可以使用命令行参数 "-J X" 来指定使用哪种jvmtype, X的值为上面的 knownVMs数组中的其中一种name;
    //即如果 -J -server 或 -J -client参数, 则jvmtype值为 "server" 或 "client";
     
    //如果没有指定 "-J"选项, 则会选择 knownVMs中的第一个vmdesc的name,即"server"
    jvmtype = CheckJvmType(pargc, pargv, JNI_FALSE);

    //使用jrepath和jvmtype拼接 jvmpath, 这里结果为:
  	// "/Users/gwwwwt/jvm/jdk12/build/macosx-x86_64-server-fastdebug/jdk/lib/server/libjvm.dylib"
    if (!GetJVMPath(jrepath, jvmtype, jvmpath, so_jvmpath)) {
        JLI_ReportErrorMessage(CFG_ERROR8, jvmtype, jvmpath);
        exit(4);
    }

    /*
     * Mac OS X requires the Cocoa event loop to be run on the "main"
     * thread. Spawn off a new thread to run main() and pass
     * this thread off to the Cocoa event loop.
     */
    MacOSXStartup(argc, argv);

    return;
}
```

### 2.2 ParseArguments 和 SetJavaCommandLineProp 和 SetJavaLauncherProp 函数

> **直接说结论：**
>
> **经过三个函数的解析，最终都会将命令行参数、运行主类、Launcher信息等添加到 java.c中定义的静态变量 options中。**
>
> **options类型为：`static JavaVMOption *options;`**
>
> > ```c
> > typedef struct JavaVMOption {
> >     char *optionString;
> >     void *extraInfo;
> > } JavaVMOption;
> > ```
>
> **以简单的`java idea.NotifyDemo`命令，最终会往options中添加的结果为：**
>
> > **options[0].optionString = "-Djava.class.path=."**
> >
> > **options[1].optionString = "-Dsun.java.command=idea.NotifyDemo"**
> >
> > **options[2].optionString = "-Dsun.java.launcher=SUN_STANDARD"**

### 2.3 JVMInit -> ContinueInNewThread->ContinueInNewThread0函数

> 源文件：src/java.base/macosx/native/libjli/java_md_macosx.m
>
> > **注意：这儿又启动了一个线程；**
>
> > **在ContinueInNewThread()函数中设置了JavaMain线程启动时的栈大小为1M(1024*1024)，`ContinueInNewThread0函数`实际启动了调用JavaMain函数的新线程。**

```c
int JVMInit(InvocationFunctions* ifn, jlong threadStackSize,
                 int argc, char **argv,
                 int mode, char *what, int ret) {
    if (sameThread) { //sameThread值为False, 所以会执行到else块中去
        //略...
    } else {
        return ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret);
    }
}

//初始化threadStackSize; 包装JavaMainArgs结构;
int ContinueInNewThread(InvocationFunctions* ifn, jlong threadStackSize,
                    int argc, char **argv, int mode, char *what, int ret)
{
    if (threadStackSize == 0) {
      struct JDK1_1InitArgs args1_1;
      memset((void*)&args1_1, 0, sizeof(args1_1));
      args1_1.version = JNI_VERSION_1_1;
      
			//参考2.3.1节, 会设置args1_1->javaStackSize = 1024 * 1024
      //且 args1_1->version = JNI_VERSION_1_2
      ifn->GetDefaultJavaVMInitArgs(&args1_1);  
      if (args1_1.javaStackSize > 0) {
         threadStackSize = args1_1.javaStackSize;
      }
    }

    { /* Create a new thread to create JVM and invoke main method */
      JavaMainArgs args; //JavaMainArgs实际就是包装argc,argv,mode,what和ifn的结构体;
      int rslt;

      args.argc = argc;
      args.argv = argv;
      args.mode = mode;
      args.what = what;
      args.ifn = *ifn;

      //==== 重要, 启动新线程, 调用JavaMain函数
      rslt = ContinueInNewThread0(JavaMain, threadStackSize, (void*)&args);

      return (ret != 0) ? ret : rslt;
    }
}

//启动新线程, 在新线程中调用JavaMain函数进行处理, stack_size值为1M, 在创建JavaMain线程时被设置为 attr中的属性;
int ContinueInNewThread0(int (JNICALL *continuation)(void *), jlong stack_size, void * args) {
    int rslt;
    pthread_t tid;
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

    if (stack_size > 0) {
      pthread_attr_setstacksize(&attr, stack_size);
    }
    pthread_attr_setguardsize(&attr, 0);

    if (pthread_create(&tid, &attr, (void *(*)(void*))continuation, (void*)args) == 0) {
      void * tmp;
      pthread_join(tid, &tmp); //当前线程会阻塞等待新线程执行完成
      rslt = (int)(intptr_t)tmp;
    }

    pthread_attr_destroy(&attr);
    return rslt;
}
```

#### 2.3.1 JNI_GetDefaultJavaVMInitArgs函数

> 源文件：src/hotspot/share/prims/jni.cpp
>
> **参考第2节，ifn->GetDefaultJavaVMInitArgs(&args1_1); 实际调用的就是JNI_GetDefaultJavaVMInitArgs函数**
>
> > **JNI_GetDefaultJavaVMInitArgs(args)主要步骤是 args->javaStackSize = 1024 *1024**

```c++
__attribute__((visibility("default"))) jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *args_) {
  
  JDK1_1InitArgs *args = (JDK1_1InitArgs *)args_;
  jint ret = JNI_ERR;

  if (args->version == JNI_VERSION_1_1) { //args->version初始化时是 JNI_VERSION_1_1
    args->version = JNI_VERSION_1_2;

    assert(jlong(ThreadStackSize) * K < INT_MAX, "integer overflow");
    args->javaStackSize = (jint)(ThreadStackSize * K);
  }
  return ret;
}

```



## 3. JavaMain函数

> 源文件：src/java.base/share/native/libjli/java.c
>
> **由上面的说明可知，启动了一个新线程执行JavaMain函数，而命令行参数及其它信息则封装成了JavaMainArgs结构体作为JavaMain的参数传入。**

```c
int JNICALL JavaMain(void * _args)
{
    //按照简单的"java idea.NotifyDemo"来执行的话, argc和argv可忽略;
    //mode值为1, 
    //what为"idea.NotifyDemo", 
    //ifn中封装了工具函数指针: 
    //	`CreateJavaVM: JNI_CreateJavaVM (jni.cpp)`
		//	`GetDefaultJavaVMInitArgs: JNI_GetDefaultJavaVMInitArgs (jni.cpp)`
		//	`GetCreatedJavaVMs: JNI_GetCreatedJavaVMs (jni.cpp)`
    JavaMainArgs *args = (JavaMainArgs *)_args;
    int argc = args->argc;
    char **argv = args->argv;
    int mode = args->mode;
    char *what = args->what;
    InvocationFunctions ifn = args->ifn;

    JavaVM *vm = 0;
    JNIEnv *env = 0;
    jclass mainClass = NULL;
    jclass appClass = NULL; // actual application class being launched
    jmethodID mainID;
    jobjectArray mainArgs;
    int ret = 0;
    jlong start, end;

    RegisterThread(); //在MacOS上实现为空, 在Windows或*nixes中可能会有实现
  
    //初始化vm
    if (!InitializeJVM(&vm, &env, &ifn)) {
        JLI_ReportErrorMessage(JVM_ERROR1);
        exit(1);
    }

    if (showSettings != NULL) {
        ShowSettings(env, showSettings);
        CHECK_EXCEPTION_LEAVE(1);
    }

    // show resolved modules and continue
    if (showResolvedModules) {
        ShowResolvedModules(env);
        CHECK_EXCEPTION_LEAVE(1);
    }

    // list observable modules, then exit
    if (listModules) {
        ListModules(env);
        CHECK_EXCEPTION_LEAVE(1);
        LEAVE();
    }

    // describe a module, then exit
    if (describeModule != NULL) {
        DescribeModule(env, describeModule);
        CHECK_EXCEPTION_LEAVE(1);
        LEAVE();
    }

    if (printVersion || showVersion) {
        PrintJavaVersion(env, showVersion);
        CHECK_EXCEPTION_LEAVE(0);
        if (printVersion) {
            LEAVE();
        }
    }

    // modules have been validated at startup so exit
    if (validateModules) {
        LEAVE();
    }

    /* If the user specified neither a class name nor a JAR file */
    if (printXUsage || printUsage || what == 0 || mode == LM_UNKNOWN) {
        PrintUsage(env, printXUsage);
        CHECK_EXCEPTION_LEAVE(1);
        LEAVE();
    }

    FreeKnownVMs(); /* after last possible PrintUsage */

    ret = 1;

    /*
     * Get the application's main class. It also checks if the main
     * method exists.
     *
     * See bugid 5030265.  The Main-Class name has already been parsed
     * from the manifest, but not parsed properly for UTF-8 support.
     * Hence the code here ignores the value previously extracted and
     * uses the pre-existing code to reextract the value.  This is
     * possibly an end of release cycle expedient.  However, it has
     * also been discovered that passing some character sets through
     * the environment has "strange" behavior on some variants of
     * Windows.  Hence, maybe the manifest parsing code local to the
     * launcher should never be enhanced.
     *
     * Hence, future work should either:
     *     1)   Correct the local parsing code and verify that the
     *          Main-Class attribute gets properly passed through
     *          all environments,
     *     2)   Remove the vestages of maintaining main_class through
     *          the environment (and remove these comments).
     *
     * This method also correctly handles launching existing JavaFX
     * applications that may or may not have a Main-Class manifest entry.
     */
    mainClass = LoadMainClass(env, mode, what);
    CHECK_EXCEPTION_NULL_LEAVE(mainClass);
    /*
     * In some cases when launching an application that needs a helper, e.g., a
     * JavaFX application with no main method, the mainClass will not be the
     * applications own main class but rather a helper class. To keep things
     * consistent in the UI we need to track and report the application main class.
     */
    appClass = GetApplicationClass(env);
    NULL_CHECK_RETURN_VALUE(appClass, -1);

    /* Build platform specific argument array */
    mainArgs = CreateApplicationArgs(env, argv, argc);
    CHECK_EXCEPTION_NULL_LEAVE(mainArgs);

    if (dryRun) {
        ret = 0;
        LEAVE();
    }

    /*
     * PostJVMInit uses the class name as the application name for GUI purposes,
     * for example, on OSX this sets the application name in the menu bar for
     * both SWT and JavaFX. So we'll pass the actual application class here
     * instead of mainClass as that may be a launcher or helper class instead
     * of the application class.
     */
    PostJVMInit(env, appClass, vm);
    CHECK_EXCEPTION_LEAVE(1);

    /*
     * The LoadMainClass not only loads the main class, it will also ensure
     * that the main method's signature is correct, therefore further checking
     * is not required. The main method is invoked here so that extraneous java
     * stacks are not in the application stack trace.
     */
    mainID = (*env)->GetStaticMethodID(env, mainClass, "main",
                                       "([Ljava/lang/String;)V");
    CHECK_EXCEPTION_NULL_LEAVE(mainID);

    /* Invoke main method. */
    (*env)->CallStaticVoidMethod(env, mainClass, mainID, mainArgs);

    /*
     * The launcher's exit code (in the absence of calls to
     * System.exit) will be non-zero if main threw an exception.
     */
    ret = (*env)->ExceptionOccurred(env) == NULL ? 0 : 1;

    LEAVE();
}
```

### 3.1 JavaVM、JNIEnv

> **JNINativeInterface_结构体定义有点长，就不在这儿贴了，之后遇到后再进行解析**

```c
//--- 这是干啥的
typedef const struct JNIInvokeInterface_ *JavaVM;

struct JNIInvokeInterface_ {
    void *reserved0;
    void *reserved1;
    void *reserved2;

    jint (JNICALL *DestroyJavaVM)(JavaVM *vm);

    jint (JNICALL *AttachCurrentThread)(JavaVM *vm, void **penv, void *args);

    jint (JNICALL *DetachCurrentThread)(JavaVM *vm);

    jint (JNICALL *GetEnv)(JavaVM *vm, void **penv, jint version);

    jint (JNICALL *AttachCurrentThreadAsDaemon)(JavaVM *vm, void **penv, void *args);
};


//---- JNI 调用接口, 声明了N多函数指针
typedef const struct JNINativeInterface_ *JNIEnv;
```

### 3.2 jobject、jclass等

> 源文件：build/macosx-x86_64-server-fastdebug/support/modules_include/java.base/jni.h

```c
struct _jobject;

typedef struct _jobject *jobject;
typedef jobject jclass;
typedef jobject jthrowable;
typedef jobject jstring;
typedef jobject jarray;
typedef jarray jbooleanArray;
typedef jarray jbyteArray;
typedef jarray jcharArray;
typedef jarray jshortArray;
typedef jarray jintArray;
typedef jarray jlongArray;
typedef jarray jfloatArray;
typedef jarray jdoubleArray;
typedef jarray jobjectArray;

typedef jobject jweak;

typedef union jvalue {
    jboolean z;
    jbyte    b;
    jchar    c;
    jshort   s;
    jint     i;
    jlong    j;
    jfloat   f;
    jdouble  d;
    jobject  l;
} jvalue;

struct _jfieldID;
typedef struct _jfieldID *jfieldID;

struct _jmethodID;
typedef struct _jmethodID *jmethodID;

/* Return values from jobjectRefType */
typedef enum _jobjectType {
     JNIInvalidRefType    = 0,
     JNILocalRefType      = 1,
     JNIGlobalRefType     = 2,
     JNIWeakGlobalRefType = 3
} jobjectRefType;
```

### 3.3 InitializeJVM ->JNI_CreateJavaVM -> JNI_CreateJavaVM_inner函数

> **InitializeJVM()函数作用：初始化Java Virtual Machine，并且会在使用完options数组信息后释放options数组。关于options数组信息填充参考2.2节。**
>
> **函数调用链：InitializeJVM() => JNI_CreateJavaJVM() => JNI_CreateJavaVM_inner()**
>
> **源文件: src/java.base/share/native/libjli/java.c**

```c++
static jboolean InitializeJVM(JavaVM **pvm, JNIEnv **penv, InvocationFunctions *ifn)
{
    JavaVMInitArgs args;
    jint r;

    memset(&args, 0, sizeof(args));
    args.version  = JNI_VERSION_1_2;
    args.nOptions = numOptions;
    args.options  = options;
    args.ignoreUnrecognized = JNI_FALSE;

    r = ifn->CreateJavaVM(pvm, (void **)penv, &args);
    JLI_MemFree(options);
    return r == JNI_OK;
}

//源文件:src/hotspot/share/prims/jni.cpp
_JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_CreateJavaVM(JavaVM **vm, void **penv, void *args) {
  jint result = JNI_ERR;

  result = JNI_CreateJavaVM_inner(vm, penv, args);

  return result;
}
```



#### 3.3.1 JNI_CreateJavaVM_inner函数

> **源文件：src/hotspot/share/prims/jni.cpp**
>
> > **定义的全局变量：**
> >
> > **`volatile int vm_created = 0;`**
> >
> > **`volatile int safe_to_recreate_vm = 1;`**

```c++
static jint JNI_CreateJavaVM_inner(JavaVM **vm, void **penv, void *args) {

  jint result = JNI_ERR;

  // 测试 Atomic::xchg 是否能在本平台上正常工作. 因为后面的同步需要用到本方法.
	#if defined(ZERO) && defined(ASSERT)
  {
    jint a = 0xcafebabe;
    jint b = Atomic::xchg((jint) 0xdeadbeef, &a);
    void *c = &a;
    void *d = Atomic::xchg(&b, &c);
    assert(a == (jint) 0xdeadbeef && b == (jint) 0xcafebabe, "Atomic::xchg() works");
    assert(c == &b && d == &a, "Atomic::xchg() works");
  }
	#endif // ZERO && ASSERT

  //判断vm_created和safe_to_recreate_vm两个变量的值是否是初始值, 如果不是表示已经运行过创建vm的逻辑.
  if (Atomic::xchg(1, &vm_created) == 1) {
    return JNI_EEXIST;   // already created, or create attempt in progress
  }
  if (Atomic::xchg(0, &safe_to_recreate_vm) == 0) {
    return JNI_ERR;  // someone tried and failed and retry not allowed.
  }

  bool can_try_again = true;

  result = Threads::create_vm((JavaVMInitArgs*) args, &can_try_again);
  
  if (result == JNI_OK) {
    JavaThread *thread = JavaThread::current();
    assert(!thread->has_pending_exception(), "should have returned not OK");
    /* thread is thread_in_vm here */
    *vm = (JavaVM *)(&main_vm);
    *(JNIEnv**)penv = thread->jni_environment();

#if INCLUDE_JVMCI
    if (EnableJVMCI) {
      if (UseJVMCICompiler) {
        // JVMCI is initialized on a CompilerThread
        if (BootstrapJVMCI) {
          JavaThread* THREAD = thread;
          JVMCICompiler* compiler = JVMCICompiler::instance(true, CATCH);
          compiler->bootstrap(THREAD);
          if (HAS_PENDING_EXCEPTION) {
            HandleMark hm;
            vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
          }
        }
      }
    }
#endif

    // Tracks the time application was running before GC
    RuntimeService::record_application_start();

    // Notify JVMTI
    if (JvmtiExport::should_post_thread_life()) {
       JvmtiExport::post_thread_start(thread);
    }

    post_thread_start_event(thread);

#ifndef PRODUCT
    if (ReplayCompiles) ciReplay::replay(thread);

    // Some platforms (like Win*) need a wrapper around these test
    // functions in order to properly handle error conditions.
    VMError::test_error_handler();
#endif

    // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving.
    ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native);
  } else {
    // If create_vm exits because of a pending exception, exit with that
    // exception.  In the future when we figure out how to reclaim memory,
    // we may be able to exit with JNI_ERR and allow the calling application
    // to continue.
    if (Universe::is_fully_initialized()) {
      // otherwise no pending exception possible - VM will already have aborted
      JavaThread* THREAD = JavaThread::current();
      if (HAS_PENDING_EXCEPTION) {
        HandleMark hm;
        vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
      }
    }

    if (can_try_again) {
      // reset safe_to_recreate_vm to 1 so that retrial would be possible
      safe_to_recreate_vm = 1;
    }

    // Creation failed. We must reset vm_created
    *vm = 0;
    *(JNIEnv**)penv = 0;
    // reset vm_created last to avoid race condition. Use OrderAccess to
    // control both compiler and architectural-based reordering.
    OrderAccess::release_store(&vm_created, 0);
  }

  // Flush stdout and stderr before exit.
  fflush(stdout);
  fflush(stderr);

  return result;

}
```



#### 3.3.2 Threads.create_vm方法（核心）

> **源文件：src/hotspot/share/runtime/thread.cpp**
>
> > **参数：**
> >
> > **args：包含命令行参数options**
> >
> > **\*canTryAgain = true**

```c++
jint Threads::create_vm(JavaVMInitArgs* args, bool* canTryAgain) {
  
  extern void JDK_Version_init(); //导入外部JDK_Version_init()函数

  ThreadLocalStorage::init(); //线程本地存储, 存储的 Thread* 指针, 参考《3. 线程本地存储.md》

  ostream_init(); //初始化ostream模块, 略...

  //设置在arguments.cpp中定义的全局变量_sun_java_launcher
  Arguments::process_sun_java_launcher_properties(args); 

  os::init(); //初始化os模块, 获取cpu数量, 物理内存大小等信息保存到os或os::Bsd类中的全局变量中
  
  Arguments::init_system_properties(); //参考3.3.2.2

  JDK_Version_init(); //初始化JDK_Version类信息

  //继续往Arguments::_system_properties链表中附加一些属性信息
  Arguments::init_version_specific_system_properties(); 

  // Note: this internally calls os::init_container_support()
  jint parse_result = Arguments::parse(args); //解析args中的参数

  os::init_before_ergo(); //不重要, 略

  //在用户未指定的情况下自动选择默认的垃圾收集器, 是否使用压缩指针等, 好像很重要
  jint ergo_result = Arguments::apply_ergo();

  // Final check of all 'AfterErgo' constraints after ergonomics which may change values.
  bool constraint_result = JVMFlagConstraintList::check_constraints(JVMFlagConstraint::AfterErgo);

  JVMFlagWriteableList::mark_startup();

  if (PauseAtStartup) {
    os::pause();
  }

  // 重要, 在这里注册了jvm的信号处理函数
  jint os_init_2_result = os::init_2();

  SafepointMechanism::initialize(); //初始化Safepoint

  jint adjust_after_os_result = Arguments::adjust_after_os();

  // Convert -Xrun to -agentlib: if there is no JVM_OnLoad
  // Must be before create_vm_init_agents()
  if (Arguments::init_libraries_at_startup()) {
    convert_vm_init_libraries_to_agents();
  }

  // Launch -agentlib/-agentpath and converted -Xrun agents
  if (Arguments::init_agents_at_startup()) {
    create_vm_init_agents();
  }

  // Initialize Threads state
  _thread_list = NULL;
  _number_of_threads = 0;
  _number_of_non_daemon_threads = 0;

  // Initialize global data structures and create system classes in heap
  vm_init_globals();

#if INCLUDE_JVMCI
  if (JVMCICounterSize > 0) {
    JavaThread::_jvmci_old_thread_counters = NEW_C_HEAP_ARRAY(jlong, JVMCICounterSize, mtInternal);
    memset(JavaThread::_jvmci_old_thread_counters, 0, sizeof(jlong) * JVMCICounterSize);
  } else {
    JavaThread::_jvmci_old_thread_counters = NULL;
  }
#endif // INCLUDE_JVMCI

  // Attach the main thread to this os thread
  JavaThread* main_thread = new JavaThread();
  main_thread->set_thread_state(_thread_in_vm);
  main_thread->initialize_thread_current();
  // must do this before set_active_handles
  main_thread->record_stack_base_and_size();
  main_thread->register_thread_stack_with_NMT();
  main_thread->set_active_handles(JNIHandleBlock::allocate_block());

  if (!main_thread->set_as_starting_thread()) {
    vm_shutdown_during_initialization(
                                      "Failed necessary internal allocation. Out of swap space");
    main_thread->smr_delete();
    *canTryAgain = false; // don't let caller call JNI_CreateJavaVM again
    return JNI_ENOMEM;
  }

  // Enable guard page *after* os::create_main_thread(), otherwise it would
  // crash Linux VM, see notes in os_linux.cpp.
  main_thread->create_stack_guard_pages();

  // Initialize Java-Level synchronization subsystem
  ObjectMonitor::Initialize();

  // Initialize global modules
  jint status = init_globals();
  if (status != JNI_OK) {
    main_thread->smr_delete();
    *canTryAgain = false; // don't let caller call JNI_CreateJavaVM again
    return status;
  }

  JFR_ONLY(Jfr::on_vm_init();)

  // Should be done after the heap is fully created
  main_thread->cache_global_variables();

  HandleMark hm;

  { MutexLocker mu(Threads_lock);
    Threads::add(main_thread);
  }

  // Any JVMTI raw monitors entered in onload will transition into
  // real raw monitor. VM is setup enough here for raw monitor enter.
  JvmtiExport::transition_pending_onload_raw_monitors();

  // Create the VMThread
  { TraceTime timer("Start VMThread", TRACETIME_LOG(Info, startuptime));

  VMThread::create();
    Thread* vmthread = VMThread::vm_thread();

    if (!os::create_thread(vmthread, os::vm_thread)) {
      vm_exit_during_initialization("Cannot create VM thread. "
                                    "Out of system resources.");
    }

    // Wait for the VM thread to become ready, and VMThread::run to initialize
    // Monitors can have spurious returns, must always check another state flag
    {
      MutexLocker ml(Notify_lock);
      os::start_thread(vmthread);
      while (vmthread->active_handles() == NULL) {
        Notify_lock->wait();
      }
    }
  }

  assert(Universe::is_fully_initialized(), "not initialized");
  if (VerifyDuringStartup) {
    // Make sure we're starting with a clean slate.
    VM_Verify verify_op;
    VMThread::execute(&verify_op);
  }

  // We need this to update the java.vm.info property in case any flags used
  // to initially define it have been changed. This is needed for both CDS and
  // AOT, since UseSharedSpaces and UseAOT may be changed after java.vm.info
  // is initially computed. See Abstract_VM_Version::vm_info_string().
  // This update must happen before we initialize the java classes, but
  // after any initialization logic that might modify the flags.
  Arguments::update_vm_info_property(VM_Version::vm_info_string());

  Thread* THREAD = Thread::current();

  // Always call even when there are not JVMTI environments yet, since environments
  // may be attached late and JVMTI must track phases of VM execution
  JvmtiExport::enter_early_start_phase();

  // Notify JVMTI agents that VM has started (JNI is up) - nop if no agents.
  JvmtiExport::post_early_vm_start();

  initialize_java_lang_classes(main_thread, CHECK_JNI_ERR);

  quicken_jni_functions();

  // No more stub generation allowed after that point.
  StubCodeDesc::freeze();

  // Set flag that basic initialization has completed. Used by exceptions and various
  // debug stuff, that does not work until all basic classes have been initialized.
  set_init_completed();

  LogConfiguration::post_initialize();
  Metaspace::post_initialize();

  HOTSPOT_VM_INIT_END();

  // record VM initialization completion time
#if INCLUDE_MANAGEMENT
  Management::record_vm_init_completed();
#endif // INCLUDE_MANAGEMENT

  // Signal Dispatcher needs to be started before VMInit event is posted
  os::initialize_jdk_signal_support(CHECK_JNI_ERR);

  // Start Attach Listener if +StartAttachListener or it can't be started lazily
  if (!DisableAttachMechanism) {
    AttachListener::vm_start();
    if (StartAttachListener || AttachListener::init_at_startup()) {
      AttachListener::init();
    }
  }

  // Launch -Xrun agents
  // Must be done in the JVMTI live phase so that for backward compatibility the JDWP
  // back-end can launch with -Xdebug -Xrunjdwp.
  if (!EagerXrunInit && Arguments::init_libraries_at_startup()) {
    create_vm_init_libraries();
  }

  if (CleanChunkPoolAsync) {
    Chunk::start_chunk_pool_cleaner_task();
  }

  // initialize compiler(s)
#if defined(COMPILER1) || COMPILER2_OR_JVMCI
#if INCLUDE_JVMCI
  bool force_JVMCI_intialization = false;
  if (EnableJVMCI) {
    // Initialize JVMCI eagerly when it is explicitly requested.
    // Or when JVMCIPrintProperties is enabled.
    // The JVMCI Java initialization code will read this flag and
    // do the printing if it's set.
    force_JVMCI_intialization = EagerJVMCI || JVMCIPrintProperties;

    if (!force_JVMCI_intialization) {
      // 8145270: Force initialization of JVMCI runtime otherwise requests for blocking
      // compilations via JVMCI will not actually block until JVMCI is initialized.
      force_JVMCI_intialization = UseJVMCICompiler && (!UseInterpreter || !BackgroundCompilation);
    }
  }
#endif
  CompileBroker::compilation_init_phase1(CHECK_JNI_ERR);
  // Postpone completion of compiler initialization to after JVMCI
  // is initialized to avoid timeouts of blocking compilations.
  if (JVMCI_ONLY(!force_JVMCI_intialization) NOT_JVMCI(true)) {
    CompileBroker::compilation_init_phase2();
  }
#endif

  // Pre-initialize some JSR292 core classes to avoid deadlock during class loading.
  // It is done after compilers are initialized, because otherwise compilations of
  // signature polymorphic MH intrinsics can be missed
  // (see SystemDictionary::find_method_handle_intrinsic).
  initialize_jsr292_core_classes(CHECK_JNI_ERR);

  // This will initialize the module system.  Only java.base classes can be
  // loaded until phase 2 completes
  call_initPhase2(CHECK_JNI_ERR);

  // Always call even when there are not JVMTI environments yet, since environments
  // may be attached late and JVMTI must track phases of VM execution
  JvmtiExport::enter_start_phase();

  // Notify JVMTI agents that VM has started (JNI is up) - nop if no agents.
  JvmtiExport::post_vm_start();

  // Final system initialization including security manager and system class loader
  call_initPhase3(CHECK_JNI_ERR);

  // cache the system and platform class loaders
  SystemDictionary::compute_java_loaders(CHECK_JNI_ERR);

#if INCLUDE_CDS
  if (DumpSharedSpaces) {
    // capture the module path info from the ModuleEntryTable
    ClassLoader::initialize_module_path(THREAD);
  }
#endif

#if INCLUDE_JVMCI
  if (force_JVMCI_intialization) {
    JVMCIRuntime::force_initialization(CHECK_JNI_ERR);
    CompileBroker::compilation_init_phase2();
  }
#endif

  // Always call even when there are not JVMTI environments yet, since environments
  // may be attached late and JVMTI must track phases of VM execution
  JvmtiExport::enter_live_phase();

  // Make perfmemory accessible
  PerfMemory::set_accessible(true);

  // Notify JVMTI agents that VM initialization is complete - nop if no agents.
  JvmtiExport::post_vm_initialized();

  JFR_ONLY(Jfr::on_vm_start();)

#if INCLUDE_MANAGEMENT
  Management::initialize(THREAD);

  if (HAS_PENDING_EXCEPTION) {
    // management agent fails to start possibly due to
    // configuration problem and is responsible for printing
    // stack trace if appropriate. Simply exit VM.
    vm_exit(1);
  }
#endif // INCLUDE_MANAGEMENT

  if (MemProfiling)                   MemProfiler::engage();
  StatSampler::engage();
  if (CheckJNICalls)                  JniPeriodicChecker::engage();

  BiasedLocking::init();

#if INCLUDE_RTM_OPT
  RTMLockingCounters::init();
#endif

  if (JDK_Version::current().post_vm_init_hook_enabled()) {
    call_postVMInitHook(THREAD);
    // The Java side of PostVMInitHook.run must deal with all
    // exceptions and provide means of diagnosis.
    if (HAS_PENDING_EXCEPTION) {
      CLEAR_PENDING_EXCEPTION;
    }
  }

  {
    MutexLocker ml(PeriodicTask_lock);
    // Make sure the WatcherThread can be started by WatcherThread::start()
    // or by dynamic enrollment.
    WatcherThread::make_startable();
    // Start up the WatcherThread if there are any periodic tasks
    // NOTE:  All PeriodicTasks should be registered by now. If they
    //   aren't, late joiners might appear to start slowly (we might
    //   take a while to process their first tick).
    if (PeriodicTask::num_tasks() > 0) {
      WatcherThread::start();
    }
  }

  create_vm_timer.end();
#ifdef ASSERT
  _vm_complete = true;
#endif

  if (DumpSharedSpaces) {
    MetaspaceShared::preload_and_dump(CHECK_JNI_ERR);
    ShouldNotReachHere();
  }

  return JNI_OK;
}
```

##### 3.3.2.1 os::init()

```c++
void os::init(void) {
  char dummy;   // used to get a guess on initial stack address

  //_initial_pid 一般初始化为 getpid()结果
  pid_t java_launcher_pid = (pid_t) Arguments::sun_java_launcher_pid();
  _initial_pid = (java_launcher_pid > 0) ? java_launcher_pid : getpid();

  clock_tics_per_sec = CLK_TCK;

  init_random(1234567); //_rand_seed=1234567

  //通过 getpagesize()系统调用获取系统分页大小, 再设置 public static _page_size数组数据
  //  _page_sizes[0] = getpagesize();
  //  _page_sizes[1] = 0; // sentinel
  Bsd::set_page_size(getpagesize());
  init_page_sizes((size_t) Bsd::page_size()); 

  /*
  sysctl系统调用获取到了cpu数量和内存大小, 分别保存在
  	os::_processor_count
  	os::Bsd::_physical_memory
  两个全局变量中	
  */
  Bsd::initialize_system_info(); 

  Bsd::_main_thread = pthread_self(); //保存当前线程到 Bsd::_main_thread中

  Bsd::clock_init();
  initial_time_count = javaTimeNanos();

  os::Posix::init(); //初始化系统相关信息, 略
}
```

##### 3.3.2.2 Arguments::init_system_properties()

> **初始化系统属性key/value，由SystemProperty实例包装。**
>
> > **key/value字符串由类SystemProperty包装，且SystemProperty除了包装key/value字符串外，还定义了`_internal` 和 `_writable`两个成员变量。类定义：**
> >
> > ```c++
> > class PathString : public CHeapObj<mtArguments> {
> >  protected:
> >   char* _value;
> >   ...
> > }
> > 
> > class SystemProperty : public PathString {
> >  private:
> >   char*           _key;
> >   SystemProperty* _next;
> >   bool            _internal;
> >   bool            _writeable;
> >   ...
> > }
> > ```
> >
> > > **可以看到，\_value在父类PathString中定义，\_key在SystemProperty中定义。**
> > >
> > > **此外还有一个`_next`字段，所以多个(*SystemProperty)可以构成一个单向链表。**
>
> > **Arguments中定义了多个 (PathString\*) 或 (SystemProperty\*)类型的成员变量：**
> >
> > + **_system_boot_class_path：boot class path路径**
> > + **_vm_info：vm完整信息，这里只是初始化，需要等到解析参数后再补完**
> > + **_sun_boot_library_path、_java_library_path、_java_home、_java_class_path：需要等到调用os::init_system_properties_values()后补完**
> > + **_jdk_boot_class_path_append：不知道干啥的**
> > + **_system_properties：jvm版本、名字、调试级别等信息链表，上面的boot_class等也会append到这个链表上**
>
> > **调用os::init_system_properties_values(); 来填充上面的未确定信息。**

```c++
void Arguments::init_system_properties() {
  
  _system_boot_class_path = new PathString(NULL);

  PropertyList_add(&_system_properties, 
                   new SystemProperty("java.vm.specification.name",
                   				"Java Virtual Machine Specification",  false));
  
  PropertyList_add(&_system_properties, 
                   new SystemProperty("java.vm.version", VM_Version::vm_release(),  false));
  
  PropertyList_add(&_system_properties, 
                   new SystemProperty("java.vm.name", VM_Version::vm_name(),  false));
  
  PropertyList_add(&_system_properties,
                   new SystemProperty("jdk.debug", VM_Version::jdk_debug_level(),  false));

  _vm_info = new SystemProperty("java.vm.info", VM_Version::vm_info_string(), true);

  // Following are JVMTI agent writable properties.
  _sun_boot_library_path = new SystemProperty("sun.boot.library.path", NULL,  true);
  _java_library_path = new SystemProperty("java.library.path", NULL,  true);
  _java_home =  new SystemProperty("java.home", NULL,  true);
  _java_class_path = new SystemProperty("java.class.path", "",  true);
  
  // jdk.boot.class.path.append is a non-writeable, internal property.
  // It can only be set by either:
  //    - -Xbootclasspath/a:
  //    - AddToBootstrapClassLoaderSearch during JVMTI OnLoad phase
  _jdk_boot_class_path_append = new SystemProperty("jdk.boot.class.path.append", "", false, true);

  // Add to System Property list.
  PropertyList_add(&_system_properties, _sun_boot_library_path);
  PropertyList_add(&_system_properties, _java_library_path);
  PropertyList_add(&_system_properties, _java_home);
  PropertyList_add(&_system_properties, _java_class_path);
  PropertyList_add(&_system_properties, _jdk_boot_class_path_append);
  PropertyList_add(&_system_properties, _vm_info);

  os::init_system_properties_values();
}
```

##### 3.3.2.3 Arguments::set_ergonomics_flags()方法

> 待补

##### 3.3.2.4 os::init_2()方法

> 待补