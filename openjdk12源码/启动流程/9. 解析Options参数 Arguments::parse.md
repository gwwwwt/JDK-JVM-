# Arguments::parse()方法

> **源码: arguments.cpp**

> ***`Arguments::parse()方法核心逻辑在于，将从环境变量以及命令行参数中获取到的不同来源的Options统一的进行遍历，将每个Option配置项转换成Arguments中的不同字段保存的信息。这样经过Arguments::parse()方法后，所有的配置信息均可以通过Arguments中的不同字段得到，即Arguments成为一个统一的配置注册中心`***

> **ScopedVMInitArgs可以理解为JavaVMInitArgs的包装类，不同的对象包装不同的JavaVMInitArgs对象**
>
> ```c++
> class ScopedVMInitArgs : public StackObj { //arguments.cpp
>  private:
>   JavaVMInitArgs _args;
>   char*          _container_name; //区分不同的包装类作用
>   bool           _is_set;
>   char*          _vm_options_file_arg;
> 
>  public:
>   ScopedVMInitArgs(const char *container_name) {
>     _args.version = JNI_VERSION_1_2;
>     _args.nOptions = 0;
>     _args.options = NULL;
>     _args.ignoreUnrecognized = false;
>     _container_name = (char *)container_name;
>     _is_set = false;
>     _vm_options_file_arg = NULL;
>   }
>   //...
> }
> ```

```c++
// Parse entry point called from JNI_CreateJavaVM
// 参数initial_cmd_args: 命令行解析获取的options列表
jint Arguments::parse(const JavaVMInitArgs* initial_cmd_args) {
  assert(verify_special_jvm_flags(), "deprecated and obsolete flag table inconsistent"); //略

  // Initialize ranges, constraints and writeables; 
  // 其中很多宏定义, 参考《8. VMFLAGS及其它宏展开.md》中的说明
  JVMFlagRangeList::init(); //将取值在某范围内的VM标志位信息添加到JVMFlagRangeList#_rangs数组中
  JVMFlagConstraintList::init(); //将取值有限制的VM标志位信息添加到JVMFlagConstraintList#_constraints数组中
  JVMFlagWriteableList::init(); //将可写的VM标志位信息添加到JVMFlagWriteableList#_controls数组中

  // If flag "-XX:Flags=flags-file" is used it will be the first option to be processed.
  const char* hotspotrc = ".hotspotrc";
  bool settings_file_specified = false;
  bool needs_hotspotrc_warning = false;
  ScopedVMInitArgs initial_java_tool_options_args("env_var='JAVA_TOOL_OPTIONS'");
  ScopedVMInitArgs initial_java_options_args("env_var='_JAVA_OPTIONS'");

  // Pointers to current working set of containers
  JavaVMInitArgs* cur_cmd_args;
  JavaVMInitArgs* cur_java_options_args;
  JavaVMInitArgs* cur_java_tool_options_args;

  // Containers for modified/expanded options
  ScopedVMInitArgs mod_cmd_args("cmd_line_args"); 
  ScopedVMInitArgs mod_java_tool_options_args("env_var='JAVA_TOOL_OPTIONS'");
  ScopedVMInitArgs mod_java_options_args("env_var='_JAVA_OPTIONS'");

  /*
  获取"JAVA_TOOL_OPTIONS"环境变量值,将所有分析得到的JavaVMOption对象附加到
  initial_java_tool_options_args#_args#options字段中
  ---- 第1节
  */
  jint code =
      parse_java_tool_options_environment_variable(&initial_java_tool_options_args);
  if (code != JNI_OK) {
    return code;
  }
  
  /*
  逻辑大致和上面一个函数调用相同, 区别是这里获取的是"_JAVA_OPTIONS"环境变量, 并将可能的子字符串
  对应的JavaVMOption对象添加到 initial_java_options_args#_args#options中
  --- 第2节
  */
  code = parse_java_options_environment_variable(&initial_java_options_args);
  if (code != JNI_OK) {
    return code;
  }

  //--- 解析"JAVA_TOOL_OPTIONS"环境变量中定义的options; 参考第3节
  //--- 最终cur_java_tool_options_args 指向结果options数组
  code = expand_vm_options_as_needed(initial_java_tool_options_args.get(),
                                     &mod_java_tool_options_args,
                                     &cur_java_tool_options_args);
  if (code != JNI_OK) {
    return code;
  }
 
  //--- 解析"《6. 命令行转Option ParseArguments.md》中获取的命令行参数解析的Options"; 
  //--- 方法调用参考第3节
  //--- cur_cmd_args指向命令行获取的options解析后的结果
  code = expand_vm_options_as_needed(initial_cmd_args,
                                     &mod_cmd_args,
                                     &cur_cmd_args);
  if (code != JNI_OK) {
    return code;
  }
  
  //--- 解析"_JAVA_OPTIONS"环境变量中定义的options; 参考第3节
  //--- cur_java_options_args指向最终结果options
  code = expand_vm_options_as_needed(initial_java_options_args.get(),
                                     &mod_java_options_args,
                                     &cur_java_options_args);
  if (code != JNI_OK) {
    return code;
  }
  //--- 注意上面三种options数组解析的顺序, 因为可能会涉及到覆盖配置参数的问题

  //--- 检查各种JVM参数中是否指定了输出文件
  //--- 参考3.1节, 无论上面哪种options数组中包含"-XX:Flags"配置, 
  //--- 如果包含, 则 Arguments::_jvm_flags_file 非NULL
  //--- 如果不包含, 则该字段为null
  const char* flags_file = Arguments::get_jvm_flags_file();
  settings_file_specified = (flags_file != NULL);

  //--- 如果options数组中包含-XX:+IgnoreUnrecognizedVMOptions选项,
  //--- 则全局变量IgnoreUnrecognizedVMOptions会被设置为true
  //--- 否则该变量默认情况下为false
  
  //--- 如果IgnoreUnrecognizedVMOptions为true, 
  //--- 则更新三个结果options数组中的字段ignoreUnrecognized为true
  if (IgnoreUnrecognizedVMOptions) {
    cur_cmd_args->ignoreUnrecognized = true;
    cur_java_tool_options_args->ignoreUnrecognized = true;
    cur_java_options_args->ignoreUnrecognized = true;
  }

  //解析flag file内容; 如果用户配置了-XX:Flags,则解析该配置path的文件内容
  //如果用户未配置-XX:Flags, 则默认读取".hotspotrc"文件
  if (settings_file_specified) {
    if (!process_settings_file(flags_file, true,
                               cur_cmd_args->ignoreUnrecognized)) {
      return JNI_EINVAL;
    }
  } else {
    // Parse default .hotspotrc settings file
    if (!process_settings_file(".hotspotrc", false,
                               cur_cmd_args->ignoreUnrecognized)) {
      return JNI_EINVAL;
    }
  }

  //--- 如果包含配置 "-XX:+PrintVMOptions", 则本变量值为true
  //--- 否则为默认的false; 为true时打印options
  if (PrintVMOptions) { 
    print_options(cur_java_tool_options_args);
    print_options(cur_cmd_args);
    print_options(cur_java_options_args);
  }

  // --- 根据三个来源的options数组: JAVA_TOOL_OPTIONS, _JAVA_OPTIONS, 命令行选项
  // --- 进行统一处理, 参考第4节
  // --- ***重要***
  jint result = parse_vm_init_args(cur_java_tool_options_args,
                                   cur_java_options_args,
                                   cur_cmd_args);

  if (result != JNI_OK) {
    return result;
  }

  // 默认为 jvm_path/classes.jsa, 略
  SharedArchivePath = get_shared_archive_path();
  if (SharedArchivePath == NULL) {
    return JNI_ENOMEM;
  }

  // Set up VerifySharedSpaces, 略
  if (FLAG_IS_DEFAULT(VerifySharedSpaces) && SharedArchiveFile != NULL) {
    VerifySharedSpaces = true;
  }

  // UseLargePages is not yet supported on BSD and AIX. 略
#if defined(_ALLBSD_SOURCE) || defined(AIX)  
  UNSUPPORTED_OPTION(UseLargePages);
#endif

  ArgumentsExt::report_unsupported_options(); //MacOS下为空方法体

  if (!handle_deprecated_print_gc_flags()) { //略
    return JNI_EINVAL;
  }

  // --- 参考第5节, 设置对象对齐变量值
  set_object_alignment();

  return JNI_OK;
}
```



## 1. parse_java_tool_options_environment_variable方法

> **源码: arguments.cpp**
>
> **本方法最终调用到了`Arguments::parse_options_buffer方法`，按照下面的方法说明，`name参数标识的环境变量字符串按空格分隔为多个Token。但如果两个匹配的引号之间有空格，却不会分隔，而是将引号间的字符串认为是一个完整的子字符串。此外，引号必须匹配。`**

```c++
jint Arguments::parse_java_tool_options_environment_variable(ScopedVMInitArgs* args) {
  return parse_options_environment_variable("JAVA_TOOL_OPTIONS", args);
}

// --- 中间调用方法
// --- 参数name: 预期的环境变量key
// --- 参数vm_args: 存储解析环境变量后的options列表结果
jint Arguments::parse_options_environment_variable(const char* name,
                                                   ScopedVMInitArgs* vm_args) {
  char *buffer = ::getenv(name); //获取环境变量字符串

  // Don't check this environment variable if user has special privileges
  // (e.g. unix su command).
  if (buffer == NULL || os::have_special_privileges()) {
    return JNI_OK;
  }

  if ((buffer = os::strdup(buffer)) == NULL) {
    return JNI_ENOMEM;
  }

  jio_fprintf(defaultStream::error_stream(),
              "Picked up %s: %s\n", name, buffer);

  //核心逻辑
  int retcode = parse_options_buffer(name, buffer, strlen(buffer), vm_args);

  os::free(buffer);
  return retcode;
}

// --- 核心调用方法
// --- name: 环境变量key
// --- buffer: 环境变量key对应的value字符串
// --- buf_len: buffer字符串长度
// --- vm_args: 存储解析buffer字符串后的options列表
jint Arguments::parse_options_buffer(const char* name, char* buffer, const size_t buf_len, 
                                     ScopedVMInitArgs* vm_args) {
  // Construct option array
  GrowableArray<JavaVMOption> *options = 
    new (ResourceObj::C_HEAP, mtArguments) GrowableArray<JavaVMOption>(2, true);    

  char *buffer_end = buffer + buf_len; //指针索引最大限制
  char *opt_hd = buffer; //第一个Token开始位置
  char *wrt = buffer; //wrt指向下一个要更新的字符位置
  char *rd = buffer; //rd指向下一个要读取的字符位置

  while (rd < buffer_end) { // parse all options
    // isspace是系统调用API; 跳过子字符串可能的多个前导空白字符
    while (rd < buffer_end && isspace(*rd)) {
      rd++;
    }

    if (rd >= buffer_end) {
      break;
    }

    // Remember this is where we found the head of the token.
    opt_hd = wrt;

    //buffer字符串是由一个或多个连接的空格分隔的Token
    while (rd < buffer_end && !isspace(*rd)) {
      /*
      如果遇到单引号或双引号, 并不会复制引号, 但需要往后查找另一个匹配的引号;
      即遇到单引号的话, 则向往查找单引号; 或双引号, 则找双引号; 用quote标识; 
      将两个引号之间的字符串复制到wrt处; 
      
      如果向后没有查找到匹配的引号, 则打印错误信息并返回JNI_ERR
      */
      if (*rd == '\'' || *rd == '"') {      
        int quote = *rd;                    
        rd++;                        
        while (rd < buffer_end && *rd != quote) { //同样会跳过引号中的空格
          *wrt++ = *rd++;                   
        }

        if (rd < buffer_end) {
          rd++;                             
        } else {
          jio_fprintf(defaultStream::error_stream(),
                      "Unmatched quote in %s\n", name);
          delete options;
          return JNI_ERR;
        }
      } else {
        *wrt++ = *rd++;  //复制rd处的字符到wrt, 并更新rd/wrt位置
      }
    }

    *wrt++ = '\0'; //遇到空格, 则wrt即标识了一个Token的结尾索引, 则附加'\0'

    JavaVMOption option;
    //opt_hd存储了字符串的开始索引, 则直接用本字符串构造option对象
    option.optionString = opt_hd; 
    option.extraInfo = NULL;

    options->append(option);   //附加到options数组中         

    rd++;  // Advance to next character
  }

  //遍历完成之后将options设置到vm_args对象中
  jint status = vm_args->set_args(options);

  delete options;
  return status;
}
```



## 2. parse_java_options_environment_variable方法

```c++
//同样调用的parse_options_environment_variable方法;
//但环境变量key参数: "_JAVA_OPTIONS"
//其它逻辑与第1节相同
jint Arguments::parse_java_options_environment_variable(ScopedVMInitArgs* args) {
  return parse_options_environment_variable("_JAVA_OPTIONS", args);
}
```



## 3. expand_vm_options_as_needed方法

```c++
// 主要扩展在 args_in 中可能存在的  -XX:VMOptionsFile 参数
//args_in参数: 包含要遍历并处理options数组, 输入
//mod_args参数: 参考3.1节, 用于在遇到 "-XX:VMOptionsFile"参数时保存合并结果
//args_out参数: 输出结果, 指向结果options数组
jint Arguments::expand_vm_options_as_needed(const JavaVMInitArgs* args_in,
                                            ScopedVMInitArgs* mod_args,
                                            JavaVMInitArgs** args_out) {
  jint code = match_special_option_and_act(args_in, mod_args);
  if (code != JNI_OK) {
    return code;
  }
  //如果if判断为true, 表示args_in->options中确实包含"-XX:VMOptionsFile"选项
  //所以mod_args中为合并结果, 所以args_out需要指向mod_args->options数组
  //否则, args_out直接指向args_in即可
  if (mod_args->is_set()) {
    *args_out = mod_args->get();
  } else {
    *args_out = (JavaVMInitArgs *)args_in; 
  }
  return JNI_OK;
}
```



### 3.1 match_special_option_and_act方法

> **函数作用: **
>
> **遍历args->options数组，处理对应的参数。其实只处理了几个JVM配置参数，但逻辑可以分为几类：**
>
> 1. **如果是一般的标志位配置，则相应的打开/关闭全局bool变量值即可; 如"-XX:+PrintVMOptions"等**
>
> 2. **"-XX:Flags"开头的配置，则设置Arguments::_jvm_flags_file**
>
> 3. **"-XX:VMOptionsFile"配置，是本方法重点处理的参数。参考下面的逻辑说明，如果args->options中包含了这一选项，则代码会读取该参数值指向的文件，并将文件内容解析成一个options数组。这个文件options数组和args->options数组，这两个数组内容合并到args_out->options数组后，再继续遍历。具体合并和遍历逻辑参考代码注释。**
>
>    > **即只有在args->options中包含`-XX:VMOptionsFile`配置项的情况下，才会用到args_out参数。**

```c++
jint Arguments::match_special_option_and_act(const JavaVMInitArgs* args,
                                             ScopedVMInitArgs* args_out) {
  //构造一个和args_out相同container_name的对象
  ScopedVMInitArgs vm_options_file_args(args_out->container_name());
  
  const char* tail;

  //遍历args->options数组
  for (int index = 0; index < args->nOptions; index++) {
    const JavaVMOption* option = args->options + index;
    if (ArgumentsExt::process_options(option)) { //process_options直接返回false
      continue;
    }
    //option中字符串以"-XX:Flags="开头, tail保存之后的字符串
    if (match_option(option, "-XX:Flags=", &tail)) {
      //调用 Arguments::_jvm_flags_file 为tail字符串指示的路径
      Arguments::set_jvm_flags_file(tail);
      continue;
    }
    //option中字符串以"-XX:VMOptionsFile="开头
    if (match_option(option, "-XX:VMOptionsFile=", &tail)) {
      //如果遇到重复的参数, 即之前已经处理过相同的参数, 打印错误信息后返回错误代码
      if (vm_options_file_args.found_vm_options_file_arg()) {
        return JNI_EINVAL;
      }
      //设置vm_options_file_args->_vm_options_file_arg字段
      vm_options_file_args.set_vm_options_file_arg(option->optionString);
   
      /*
      insert_vm_options_file方法逻辑:
      1. tail为"-XX:VMOptionsFile="标志指示的文件路径, 检查该文件路径对应的是否是文件, 
      文件是否可读, 文件是否有内容. 如果判断不通过, 打印错误内容并返回错误标志. 
      2. 读取tail指示的文件内容到buffer[]字符数组中, 然后调用parse_options_buffer(见第1节)
      读取options至vm_options_file_args.
      3. 读取到vm_options_file_args中的所有JavaVMOption中不能再包含"-XX:VMOptionsFile="
      	参数, 因为出现了嵌套"-XX:VMOptionsFile="配置, 报错并返回错误标志
      4. 合并args.options 和 vm_options_file_args.options至args_out.options; 
         
         合并逻辑为: 由于args.options[index]为"-XX:VMOptionsFile="配置,
         args_out.options = 
      	 		args.option[0至(index-1)] 
      	 	+ vm_options_file_args.options 
      	 	+ args.options[(index+1)至最后]
      	即合并后并不会再包含"-XX:VMOptionsFile"配置选项,而是将它代替为文件解析后的结果
      */
      jint code = insert_vm_options_file(args, tail, index,
                                         &vm_options_file_args, args_out);
      if (code != JNI_OK) {
        return code;
      }
      //将option->optionsString设置到args_out->_vm_options_file_arg字段
      args_out->set_vm_options_file_arg(vm_options_file_args.vm_options_file_arg());
      
      //由于新解析了文件内容options, 所以也要遍历这些新的options
      //所以将args更新为 args_out->get(), 即填充完成后的options数组;
      //并将index--, 因为此时options数组中已经没有"-XX:VMOptionsFile"配置项了,
      //它已经替换成文件内容options子数组了. 
      //但循环时将index指向了下一个索引, 所以需要index--, 指向文件options开始处继续循环
      if (args_out->is_set()) {
        args = args_out->get();
        index--;
      }
      continue;
    }

    //--- 下面是根据配置选项设置对应的全局变量
    //--- 这些变量是通过 RUNTIME_FLAGS 宏定义的; 
    //--- 但具体是怎么能够在arguments.cpp中访问的, 还不清楚;
    if (match_option(option, "-XX:+PrintVMOptions")) {
      PrintVMOptions = true;
      continue;
    }
    if (match_option(option, "-XX:-PrintVMOptions")) {
      PrintVMOptions = false;
      continue;
    }
    if (match_option(option, "-XX:+IgnoreUnrecognizedVMOptions")) {
      IgnoreUnrecognizedVMOptions = true;
      continue;
    }
    if (match_option(option, "-XX:-IgnoreUnrecognizedVMOptions")) {
      IgnoreUnrecognizedVMOptions = false;
      continue;
    }
    if (match_option(option, "-XX:+PrintFlagsInitial")) {
      JVMFlag::printFlags(tty, false);
      vm_exit(0);
    }
    
    //--- 下面两个option, 略
    if (match_option(option, "-XX:NativeMemoryTracking", &tail)) {
      if (!MemTracker::check_launcher_nmt_support(tail)) {
        warning("Native Memory Tracking did not setup properly, using wrong launcher?");
      }

      if (MemTracker::verify_nmt_option()) {
        // Late initialization, still in single-threaded mode.
        if (MemTracker::tracking_level() >= NMT_summary) {
          MemTracker::init();
        }
      } else {
        vm_exit_during_initialization(
          "Syntax error, expecting -XX:NativeMemoryTracking=[off|summary|detail]", NULL);
      }
      continue;
    }
    
    if (match_option(option, "-XX:+PrintFlagsWithComments")) {
      JVMFlag::printFlags(tty, true);
      vm_exit(0);
    }
  }
  return JNI_OK;
}
```



## 4. Arguments::parse_vm_init_args方法

```c++
// Parse JavaVMInitArgs structure
jint Arguments::parse_vm_init_args(const JavaVMInitArgs *java_tool_options_args,
                                   const JavaVMInitArgs *java_options_args,
                                   const JavaVMInitArgs *cmd_line_args) {
  bool patch_mod_javabase = false;

  // Save default settings for some mode flags
  Arguments::_AlwaysCompileLoopMethods = AlwaysCompileLoopMethods; //false
  Arguments::_UseOnStackReplacement    = UseOnStackReplacement;  //false
  Arguments::_ClipInlining             = ClipInlining;  //true
  Arguments::_BackgroundCompilation    = BackgroundCompilation; //false
  if (TieredCompilation) { //false
    Arguments::_Tier3InvokeNotifyFreqLog = Tier3InvokeNotifyFreqLog;//10
    Arguments::_Tier4InvocationThreshold = Tier4InvocationThreshold;//5000
  }

  // Setup flags for mixed which is the default
  /*
  enum Mode {
    _int,       // corresponds to -Xint
    _mixed,     // corresponds to -Xmixed
    _comp       // corresponds to -Xcomp
  };
  
  设置 Arguments::_mode = _mixed
  */
  set_mode_flags(_mixed);
  
  //--- 下面分别处理三个args中的options, 处理逻辑参考4.1节 ---
  // Parse args structure generated from JAVA_TOOL_OPTIONS environment
  jint result = parse_each_vm_init_arg(java_tool_options_args, &patch_mod_javabase, JVMFlag::ENVIRON_VAR);
  if (result != JNI_OK) {
    return result;
  }

  // Parse args structure generated from the command line flags.
  result = parse_each_vm_init_arg(cmd_line_args, &patch_mod_javabase, JVMFlag::COMMAND_LINE);
  if (result != JNI_OK) {
    return result;
  }

  // Parse args structure generated from the _JAVA_OPTIONS environment
  result = parse_each_vm_init_arg(java_options_args, &patch_mod_javabase, JVMFlag::ENVIRON_VAR);
  if (result != JNI_OK) {
    return result;
  }

  // 本方法的目的: 获取CPU、内存等硬件信息, 并验证Arguments中的配置信息是否符合系统限制;
  os::init_container_support(); //在MacOS上为空方法体

  // Do final processing now that all arguments have been parsed
  // --- 参考4.2节, 对所有参数进行最终处理
  result = finalize_vm_init_args(patch_mod_javabase);
  if (result != JNI_OK) {
    return result;
  }

  return JNI_OK;
}
```



### 4.1 Arguments::parse_each_vm_init_arg方法

> ***重要： 遍历args->options中的所有option; 解析选项参数后设置到Arguments中的不同字段信息中。***

> **涉及到的Arguments类字段:**
>
> ```c++
> char** Arguments::_jvm_args_array  = NULL; //字符串数组
> int    Arguments::_num_jvm_args    = 0;    //字符串数组元素个数
> 
> static PathString *_system_boot_class_path; //boot class path, 用PathString#_value字符串表示
> 
> //boot class path, SystemProperty是PathString的子类, 内部仍用_value字符串存储; 但还可以用_next构造对象单链表
> static SystemProperty *_jdk_boot_class_path_append; 
> 
> static AgentLibraryList _libraryList; //-Xrun选项参数列表
> 
> //-agentlib 和 -agentpath 选项参数列表;
> //对于 -agentpath参数构造的AgentLibrary对象的 _is_absolute_path 值为true
> //而对于 -agentlib参数构造的AgentLibrary对象, 该属性值为false
> static AgentLibraryList _agentList; 
> 
> static SystemProperty* _system_properties;// Property list, 前面已经加入过多个Propert属性
> 
> static size_t  _min_heap_size; //-Xms; 堆最小空间字节数
> ```



> **涉及的其它类: **
>
> 1. AgentLibrary
>
>    > ***用于表示`-agentlib`、`-agentpath`、`-Xrun`的参数***
>
>    ```c++
>    class AgentLibrary : public CHeapObj<mtArguments> {
>      friend class AgentLibraryList;
>    public:
>      enum AgentState {
>        agent_invalid = 0,
>        agent_valid   = 1
>      };
>    
>     private:
>      char*           _name;
>      char*           _options;
>      void*           _os_lib;
>      bool            _is_absolute_path;
>      bool            _is_static_lib;
>      bool            _is_instrument_lib;
>      AgentState      _state; //是否有效
>      AgentLibrary*   _next;  //可形成单向链表, 用AgentLibraryList对象表示
>      //...
>    }
>    
>    class AgentLibraryList { //表示AgentLibrary单向链表
>     private:
>      AgentLibrary*   _first;
>      AgentLibrary*   _last;
>      //...
>    }
>    ```

```c++
jint Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, 
                                       JVMFlag::Flags origin) {
  const char* tail;

  for (int index = 0; index < args->nOptions; index++) { // 遍历args->options
    bool is_absolute_path = false;  // for -agentpath vs -agentlib

    const JavaVMOption* option = args->options + index;

    //option不是如下if判断中的三个配置字符串的情况下, 调用builf_jvm_args方法
    //将optionString添加到_jvm_args_array数组后, 再递增_num_jvm_args值; 
    //之后再继续下面的判断逻辑;
    //_jvm_args_array字符串数组后面会用来设置 java.vm.args PerfData字符串常量
    //省略了三个if中判断的字符串配置, 是因为它们都有自己特定对应的 PerfData字符串常量
    //所以不需要添加到_jvm_args_array中
    if (!match_option(option, "-Djava.class.path", &tail) &&
        !match_option(option, "-Dsun.java.command", &tail) &&
        !match_option(option, "-Dsun.java.launcher", &tail)) {

        build_jvm_args(option->optionString);
    }

    // --- 1. -verbose:[class/module/gc/jni]; 设置输出日志TAG
    if (match_option(option, "-verbose", &tail)) {
      if (!strcmp(tail, ":class") || !strcmp(tail, "")) {
        LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(class, load));
        LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(class, unload));
      } else if (!strcmp(tail, ":module")) {
        LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(module, load));
        LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(module, unload));
      } else if (!strcmp(tail, ":gc")) {
        LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(gc));
      } else if (!strcmp(tail, ":jni")) {
        if (FLAG_SET_CMDLINE(bool, PrintJNIResolving, true) != JVMFlag::SUCCESS) {
          return JNI_EINVAL;
        }
      }
    } 
    // --- 2. -da / -ea / -disableassertions / -enableassertions; 
    // --- 接受可选的以':'分隔的class/package name; 如 -da:java.lang.Thread
    // --- 
    else if (match_option(option, user_assertion_options, &tail, true)) {
      bool enable = option->optionString[1] == 'e'; //配置选项'-'符号后的字符是否是'e'
      if (*tail == '\0') {
        JavaAssertions::setUserClassDefault(enable);
      } else {
        assert(*tail == ':', "bogus match by match_option()");
        JavaAssertions::addOption(tail + 1, enable);
      }
    } 
    // --- 3. -dsa / -esa / -disablesystemassertions / -enablesystemassertions;
    else if (match_option(option, system_assertion_options, &tail, false)) {
      bool enable = option->optionString[1] == 'e';  //配置选项'-'符号后的字符是否是'e'
      JavaAssertions::setSystemClassDefault(enable);
    }
    // --- 4. -Xbootclasspath: 选项不再支持, 返回错误码
    else if (match_option(option, "-Xbootclasspath:", &tail)) {
        return JNI_EINVAL;
    } 
    // --- 5. -bootclasspath/a:, 
    // Arguments::append_sysclasspath逻辑:
    // 将tail字符串附加到两个字段的 _value字符串后
    // --- _system_boot_class_path->append_value(value);
    // --- _jdk_boot_class_path_append->append_value(value);
    else if (match_option(option, "-Xbootclasspath/a:", &tail)) {
      Arguments::append_sysclasspath(tail);
    }
    // --- 7. -bootclasspath/p: 不再支持, 返回错误码
    else if (match_option(option, "-Xbootclasspath/p:", &tail)) {
        return JNI_EINVAL;
    }
    // --- 8. -Xrun; 有两种传参形式: "-XrunA" 和 "-XrunA:B"
    // --- 在下面的代码中, 如果tail中不包含':'号, 则name字符串和tail字符串相同, options为null;
    // --- 如果tail中包含':'号, 则name为':'前的子字符串, options为':'后的子字符串;
    // --- 
    // add_init_library逻辑: 用name, options构造AgentLibrary对象后添加到 _libraryList中
    // --- "_libraryList.add(new AgentLibrary(name, options, false, NULL));"
    else if (match_option(option, "-Xrun", &tail)) {
      if (tail != NULL) {
        const char* pos = strchr(tail, ':');
        size_t len = (pos == NULL) ? strlen(tail) : pos - tail;
        char* name = NEW_C_HEAP_ARRAY(char, len + 1, mtArguments);
        jio_snprintf(name, len + 1, "%s", tail);

        char *options = NULL;
        if(pos != NULL) {
          size_t len2 = strlen(pos+1) + 1; // options start after ':'.  Final zero must be copied.
          options = (char*)memcpy(NEW_C_HEAP_ARRAY(char, len2, mtArguments), pos+1, len2);
        }

        add_init_library(name, options);
      }
    } 
    // --- 9. --add-reads= 选项;
    // --- 创建key为"jdk.module.addreads", value为tail字符串的Property后
    // --- 添加到 _system_properties链表中
    else if (match_option(option, "--add-reads=", &tail)) {
      if (!create_numbered_property("jdk.module.addreads", tail, addreads_count++)) {
        return JNI_ENOMEM;
      }
    } 
    // --- 10. --add-export= 选项; 同上创建Property, 
    // --- key: "jdk.module.addexports"; value: tail
    else if (match_option(option, "--add-exports=", &tail)) {
      if (!create_numbered_property("jdk.module.addexports", tail, addexports_count++)) {
        return JNI_ENOMEM;
      }
    } else if (match_option(option, "--add-opens=", &tail)) {
      if (!create_numbered_property("jdk.module.addopens", tail, addopens_count++)) {
        return JNI_ENOMEM;
      }
    } else if (match_option(option, "--add-modules=", &tail)) {
      if (!create_numbered_property("jdk.module.addmods", tail, addmods_count++)) {
        return JNI_ENOMEM;
      }
    } else if (match_option(option, "--limit-modules=", &tail)) {
      if (!create_property("jdk.module.limitmods", tail, InternalProperty)) {
        return JNI_ENOMEM;
      }
    } else if (match_option(option, "--module-path=", &tail)) {
      if (!create_property("jdk.module.path", tail, ExternalProperty)) {
        return JNI_ENOMEM;
      }
    } else if (match_option(option, "--upgrade-module-path=", &tail)) {
      if (!create_property("jdk.module.upgrade.path", tail, ExternalProperty)) {
        return JNI_ENOMEM;
      }
    } else if (match_option(option, "--patch-module=", &tail)) {
      // --patch-module=<module>=<file>(<pathsep><file>)*
      int res = process_patch_mod_option(tail, patch_mod_javabase);
      if (res != JNI_OK) {
        return res;
      }
    } else if (match_option(option, "--illegal-access=", &tail)) {
      if (!create_property("jdk.module.illegalAccess", tail, ExternalProperty)) {
        return JNI_ENOMEM;
      }
    } 
    // --- 11. -agentlib: / -agentpath: 选项;
    // --- 对于 -agentpath:, tail属性值必须是绝对路径, 所以is_absolute_path会设置为true
    // --- 对于 -agentlib:, is_absolute_path变量值仍是false
    // --- 处理逻辑大概和 8. -Xrun的逻辑相似, 区别在于: 
    // 1. 这里的name和options子字符串的分隔符为 '='号, -Xrun的参数分隔符为':'号
    // 2. 构造的AgentLibrary对象添加到了 _agentList单链表中
    else if (match_option(option, "-agentlib:", &tail) ||
          (is_absolute_path = match_option(option, "-agentpath:", &tail))) {
      if(tail != NULL) {
        const char* pos = strchr(tail, '=');
        size_t len = (pos == NULL) ? strlen(tail) : pos - tail;
        char* name = strncpy(NEW_C_HEAP_ARRAY(char, len + 1, mtArguments), tail, len);
        name[len] = '\0';
        char *options = NULL;
        if(pos != NULL) {
          options = os::strdup_check_oom(pos + 1, mtArguments);
        }

        add_init_agent(name, options, is_absolute_path);
      }
    } 
    // --- 12. -javaagent: ; 逻辑和上面 11. -agentlib/-agentpath的逻辑相似, 区别在于:
    // --- -javaagent也是构造了一个AgentLibrary对象并添加到 _agentList单链表中, 
    // --- 但 -javaagent参数不涉及参数分隔符的问题, 因为AgentLibray对象的 name值固定为"instrument";
    // --- 参数字符串整个都当作options子字符串进行处理; 
    // --- 此外, -javaagent功能需要提交load java.instrument module才能使用, 所以添加一个SystemProperty
    // --- 到了 _system_properties链表中
    else if (match_option(option, "-javaagent:", &tail)) {
      if (tail != NULL) {
        size_t length = strlen(tail) + 1;
        char *options = NEW_C_HEAP_ARRAY(char, length, mtArguments);
        jio_snprintf(options, length, "%s", tail);
        add_instrument_agent("instrument", options, false);
        // java agents need module java.instrument
        if (!create_numbered_property("jdk.module.addmods", "java.instrument", addmods_count++)) {
          return JNI_ENOMEM;
        }
      }
    } 
    // --- 13. --enable_preview; _enable_preview字段设置为true
    else if (match_option(option, "--enable-preview")) {
      set_enable_preview();
    }
    // --- 14. -Xnoclassgc; 设置全局变量 ClassUnloading为false
    else if (match_option(option, "-Xnoclassgc")) {
      if (FLAG_SET_CMDLINE(bool, ClassUnloading, false) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
    } 
    // --- 15. // -Xconcgc; 设置全局变量 UseConcMarkSweepGC为true; 
    // --- 即使用 CMS GC
    else if (match_option(option, "-Xconcgc")) {
      if (FLAG_SET_CMDLINE(bool, UseConcMarkSweepGC, true) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
      handle_extra_cms_flags("-Xconcgc uses UseConcMarkSweepGC");
    } 
    // --- 16. 关闭CMS GC
    else if (match_option(option, "-Xnoconcgc")) {
      if (FLAG_SET_CMDLINE(bool, UseConcMarkSweepGC, false) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
      handle_extra_cms_flags("-Xnoconcgc uses UseConcMarkSweepGC");
    // -Xbatch
    } else if (match_option(option, "-Xbatch")) { //略
      if (FLAG_SET_CMDLINE(bool, BackgroundCompilation, false) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
    }
    // --- 17. -Xmn 新生代空间大小; 
    // --- parse_memory_size会处理类似"3M", "5G"格式的字符串, 转换成字节数后再设置到long_initial_young_size
    // --- 当然如果遇到非法格式输入, 会返回错误代码
    // --- 最后会将 MaxNewSize 和 NewSize 更新为 long_initial_young_size大小
    else if (match_option(option, "-Xmn", &tail)) { 
      julong long_initial_young_size = 0;
      ArgsRange errcode = parse_memory_size(tail, &long_initial_young_size, 1);
      if (errcode != arg_in_range) {
        return JNI_EINVAL;
      }
      if (FLAG_SET_CMDLINE(size_t, MaxNewSize, (size_t)long_initial_young_size) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
      if (FLAG_SET_CMDLINE(size_t, NewSize, (size_t)long_initial_young_size) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
    } 
    // --- 18. -Xms; 设置堆最小空间字节数; 
    // --- 同样会调用parse_memory_size对参数进行处理, 转换成字节大小
    // --- 而且会更新 Arguments::_min_heap_size 字段值
    // --- 设置 InitialHeapSize 变量值
    else if (match_option(option, "-Xms", &tail)) {
      julong long_initial_heap_size = 0;
      ArgsRange errcode = parse_memory_size(tail, &long_initial_heap_size, 0);
      if (errcode != arg_in_range) {
        return JNI_EINVAL;
      }
      set_min_heap_size((size_t)long_initial_heap_size);
      if (FLAG_SET_CMDLINE(size_t, InitialHeapSize, (size_t)long_initial_heap_size) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
    } 
    // --- 19. -Xmx; 堆最大可用空间大小;
    // --- 逻辑同18.
    else if (match_option(option, "-Xmx", &tail) || match_option(option, "-XX:MaxHeapSize=", &tail)) {
      julong long_max_heap_size = 0;
      ArgsRange errcode = parse_memory_size(tail, &long_max_heap_size, 1);
      if (errcode != arg_in_range) {
        return JNI_EINVAL;
      }
      if (FLAG_SET_CMDLINE(size_t, MaxHeapSize, (size_t)long_max_heap_size) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
    } 
    // --- 20. -Xmaxf; 堆空间最大free比例
    else if (match_option(option, "-Xmaxf", &tail)) {
      char* err;
      int maxf = (int)(strtod(tail, &err) * 100);
      if (*err != '\0' || *tail == '\0') {
        return JNI_EINVAL;
      } else {
        if (FLAG_SET_CMDLINE(uintx, MaxHeapFreeRatio, maxf) != JVMFlag::SUCCESS) {
            return JNI_EINVAL;
        }
      }
    } 
    // --- 21. Xminf; 堆空间最小free比例
    else if (match_option(option, "-Xminf", &tail)) {
      char* err;
      int minf = (int)(strtod(tail, &err) * 100);
      if (*err != '\0' || *tail == '\0') {
        return JNI_EINVAL;
      } else {
        if (FLAG_SET_CMDLINE(uintx, MinHeapFreeRatio, minf) != JVMFlag::SUCCESS) {
          return JNI_EINVAL;
        }
      }
    }
    // --- 22. -Xss: 线程栈空间大小
    else if (match_option(option, "-Xss", &tail)) {
      intx value = 0;
      jint err = parse_xss(option, tail, &value);
      if (err != JNI_OK) {
        return err;
      }
      if (FLAG_SET_CMDLINE(intx, ThreadStackSize, value) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
    } 
    //略
    else if (match_option(option, "-Xmaxjitcodesize", &tail) ||
               match_option(option, "-XX:ReservedCodeCacheSize=", &tail)) {
      julong long_ReservedCodeCacheSize = 0;

      ArgsRange errcode = parse_memory_size(tail, &long_ReservedCodeCacheSize, 1);
      if (errcode != arg_in_range) {
        return JNI_EINVAL;
      }
      if (FLAG_SET_CMDLINE(uintx, ReservedCodeCacheSize, (uintx)long_ReservedCodeCacheSize) != JVMFlag::SUCCESS) 
      {
        return JNI_EINVAL;
      }
    } 
    //略
    else if (match_option(option, "-Xrs")) {
          // Classic/EVM option, new functionality
      if (FLAG_SET_CMDLINE(bool, ReduceSignalUsage, true) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
    } 
    else if (match_option(option, "-D", &tail)) {
      const char* value;
      if (match_option(option, "-Djava.endorsed.dirs=", &value) &&
            *value!= '\0' && strcmp(value, "\"\"") != 0) {
        // abort if -Djava.endorsed.dirs is set
        return JNI_EINVAL;
      }
      if (match_option(option, "-Djava.ext.dirs=", &value) &&
            *value != '\0' && strcmp(value, "\"\"") != 0) {
        // abort if -Djava.ext.dirs is set
        return JNI_EINVAL;
      }
      // Check for module related properties.  They must be set using the modules
      // options. For example: use "--add-modules=java.sql", not
      // "-Djdk.module.addmods=java.sql"
      if (is_internal_module_property(option->optionString + 2)) {
        needs_module_property_warning = true;
        continue;
      }

      if (!add_property(tail)) {
        return JNI_ENOMEM;
      }
      // Out of the box management support
      if (match_option(option, "-Dcom.sun.management", &tail)) {
#if INCLUDE_MANAGEMENT
        if (FLAG_SET_CMDLINE(bool, ManagementServer, true) != JVMFlag::SUCCESS) {
          return JNI_EINVAL;
        }
        // management agent in module jdk.management.agent
        if (!create_numbered_property("jdk.module.addmods", "jdk.management.agent", addmods_count++)) {
          return JNI_ENOMEM;
        }
#endif
      }
    // -Xint
    } else if (match_option(option, "-Xint")) {
          set_mode_flags(_int);
    // -Xmixed
    } else if (match_option(option, "-Xmixed")) {
          set_mode_flags(_mixed);
    // -Xcomp
    } else if (match_option(option, "-Xcomp")) {
      // for testing the compiler; turn off all flags that inhibit compilation
          set_mode_flags(_comp);
    // -Xshare:dump
    } else if (match_option(option, "-Xshare:dump")) {
      if (FLAG_SET_CMDLINE(bool, DumpSharedSpaces, true) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
      set_mode_flags(_int);     // Prevent compilation, which creates objects
    // -Xshare:on
    } else if (match_option(option, "-Xshare:on")) {
      if (FLAG_SET_CMDLINE(bool, UseSharedSpaces, true) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
      if (FLAG_SET_CMDLINE(bool, RequireSharedSpaces, true) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
    // -Xshare:auto
    } else if (match_option(option, "-Xshare:auto")) {
      if (FLAG_SET_CMDLINE(bool, UseSharedSpaces, true) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
      if (FLAG_SET_CMDLINE(bool, RequireSharedSpaces, false) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
    // -Xshare:off
    } else if (match_option(option, "-Xshare:off")) {
      if (FLAG_SET_CMDLINE(bool, UseSharedSpaces, false) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
      if (FLAG_SET_CMDLINE(bool, RequireSharedSpaces, false) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
    // -Xverify
    } else if (match_option(option, "-Xverify", &tail)) {
      if (strcmp(tail, ":all") == 0 || strcmp(tail, "") == 0) {
        if (FLAG_SET_CMDLINE(bool, BytecodeVerificationLocal, true) != JVMFlag::SUCCESS) {
          return JNI_EINVAL;
        }
        if (FLAG_SET_CMDLINE(bool, BytecodeVerificationRemote, true) != JVMFlag::SUCCESS) {
          return JNI_EINVAL;
        }
      } else if (strcmp(tail, ":remote") == 0) {
        if (FLAG_SET_CMDLINE(bool, BytecodeVerificationLocal, false) != JVMFlag::SUCCESS) {
          return JNI_EINVAL;
        }
        if (FLAG_SET_CMDLINE(bool, BytecodeVerificationRemote, true) != JVMFlag::SUCCESS) {
          return JNI_EINVAL;
        }
      } else if (strcmp(tail, ":none") == 0) {
        if (FLAG_SET_CMDLINE(bool, BytecodeVerificationLocal, false) != JVMFlag::SUCCESS) {
          return JNI_EINVAL;
        }
        if (FLAG_SET_CMDLINE(bool, BytecodeVerificationRemote, false) != JVMFlag::SUCCESS) {
          return JNI_EINVAL;
        }
      } else if (is_bad_option(option, args->ignoreUnrecognized, "verification")) {
        return JNI_EINVAL;
      }
    // -Xdebug
    } else if (match_option(option, "-Xdebug")) {
      // note this flag has been used, then ignore
      set_xdebug_mode(true);
    // -Xnoagent
    } else if (match_option(option, "-Xnoagent")) {
      // For compatibility with classic. HotSpot refuses to load the old style agent.dll.
    } else if (match_option(option, "-Xloggc:", &tail)) {
      // Deprecated flag to redirect GC output to a file. -Xloggc:<filename>
      log_warning(gc)("-Xloggc is deprecated. Will use -Xlog:gc:%s instead.", tail);
      _gc_log_filename = os::strdup_check_oom(tail);
    } else if (match_option(option, "-Xlog", &tail)) {
      bool ret = false;
      if (strcmp(tail, ":help") == 0) {
        fileStream stream(defaultStream::output_stream());
        LogConfiguration::print_command_line_help(&stream);
        vm_exit(0);
      } else if (strcmp(tail, ":disable") == 0) {
        LogConfiguration::disable_logging();
        ret = true;
      } else if (*tail == '\0') {
        ret = LogConfiguration::parse_command_line_arguments();
        assert(ret, "-Xlog without arguments should never fail to parse");
      } else if (*tail == ':') {
        ret = LogConfiguration::parse_command_line_arguments(tail + 1);
      }
      if (ret == false) {
        jio_fprintf(defaultStream::error_stream(),
                    "Invalid -Xlog option '-Xlog%s', see error log for details.\n",
                    tail);
        return JNI_EINVAL;
      }
    // JNI hooks
    } else if (match_option(option, "-Xcheck", &tail)) {
      if (!strcmp(tail, ":jni")) {
        CheckJNICalls = true;
      } else if (is_bad_option(option, args->ignoreUnrecognized,
                                     "check")) {
        return JNI_EINVAL;
      }
    } else if (match_option(option, "vfprintf")) {
      _vfprintf_hook = CAST_TO_FN_PTR(vfprintf_hook_t, option->extraInfo);
    } else if (match_option(option, "exit")) {
      _exit_hook = CAST_TO_FN_PTR(exit_hook_t, option->extraInfo);
    } else if (match_option(option, "abort")) {
      _abort_hook = CAST_TO_FN_PTR(abort_hook_t, option->extraInfo);
    // Need to keep consistency of MaxTenuringThreshold and AlwaysTenure/NeverTenure;
    // and the last option wins.
    } else if (match_option(option, "-XX:+NeverTenure")) {
      if (FLAG_SET_CMDLINE(bool, NeverTenure, true) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
      if (FLAG_SET_CMDLINE(bool, AlwaysTenure, false) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
      if (FLAG_SET_CMDLINE(uintx, MaxTenuringThreshold, markOopDesc::max_age + 1) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
    } else if (match_option(option, "-XX:+AlwaysTenure")) {
      if (FLAG_SET_CMDLINE(bool, NeverTenure, false) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
      if (FLAG_SET_CMDLINE(bool, AlwaysTenure, true) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
      if (FLAG_SET_CMDLINE(uintx, MaxTenuringThreshold, 0) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
    } else if (match_option(option, "-XX:MaxTenuringThreshold=", &tail)) {
      uintx max_tenuring_thresh = 0;
      if (!parse_uintx(tail, &max_tenuring_thresh, 0)) {
        jio_fprintf(defaultStream::error_stream(),
                    "Improperly specified VM option \'MaxTenuringThreshold=%s\'\n", tail);
        return JNI_EINVAL;
      }

      if (FLAG_SET_CMDLINE(uintx, MaxTenuringThreshold, max_tenuring_thresh) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }

      if (MaxTenuringThreshold == 0) {
        if (FLAG_SET_CMDLINE(bool, NeverTenure, false) != JVMFlag::SUCCESS) {
          return JNI_EINVAL;
        }
        if (FLAG_SET_CMDLINE(bool, AlwaysTenure, true) != JVMFlag::SUCCESS) {
          return JNI_EINVAL;
        }
      } else {
        if (FLAG_SET_CMDLINE(bool, NeverTenure, false) != JVMFlag::SUCCESS) {
          return JNI_EINVAL;
        }
        if (FLAG_SET_CMDLINE(bool, AlwaysTenure, false) != JVMFlag::SUCCESS) {
          return JNI_EINVAL;
        }
      }
    } else if (match_option(option, "-XX:+DisplayVMOutputToStderr")) {
      if (FLAG_SET_CMDLINE(bool, DisplayVMOutputToStdout, false) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
      if (FLAG_SET_CMDLINE(bool, DisplayVMOutputToStderr, true) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
    } else if (match_option(option, "-XX:+DisplayVMOutputToStdout")) {
      if (FLAG_SET_CMDLINE(bool, DisplayVMOutputToStderr, false) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
      if (FLAG_SET_CMDLINE(bool, DisplayVMOutputToStdout, true) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
    } else if (match_option(option, "-XX:+ExtendedDTraceProbes")) {
#if defined(DTRACE_ENABLED)
      if (FLAG_SET_CMDLINE(bool, ExtendedDTraceProbes, true) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
      if (FLAG_SET_CMDLINE(bool, DTraceMethodProbes, true) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
      if (FLAG_SET_CMDLINE(bool, DTraceAllocProbes, true) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
      if (FLAG_SET_CMDLINE(bool, DTraceMonitorProbes, true) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
#endif // defined(DTRACE_ENABLED)
#ifdef ASSERT
    } else if (match_option(option, "-XX:+FullGCALot")) {
      if (FLAG_SET_CMDLINE(bool, FullGCALot, true) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
      // disable scavenge before parallel mark-compact
      if (FLAG_SET_CMDLINE(bool, ScavengeBeforeFullGC, false) != JVMFlag::SUCCESS) {
        return JNI_EINVAL;
      }
#endif
#if INCLUDE_JFR
    } else if (match_jfr_option(&option)) {
      return JNI_EINVAL;
#endif
    } else if (match_option(option, "-XX:", &tail)) { // -XX:xxxx
      // Skip -XX:Flags= and -XX:VMOptionsFile= since those cases have
      // already been handled
      if ((strncmp(tail, "Flags=", strlen("Flags=")) != 0) &&
          (strncmp(tail, "VMOptionsFile=", strlen("VMOptionsFile=")) != 0)) {
        if (!process_argument(tail, args->ignoreUnrecognized, origin)) {
          return JNI_EINVAL;
        }
      }
    // Unknown option
    } else if (is_bad_option(option, args->ignoreUnrecognized)) {
      return JNI_ERR;
    }
  }

  // PrintSharedArchiveAndExit will turn on
  //   -Xshare:on
  //   -Xlog:class+path=info
  if (PrintSharedArchiveAndExit) {
    if (FLAG_SET_CMDLINE(bool, UseSharedSpaces, true) != JVMFlag::SUCCESS) {
      return JNI_EINVAL;
    }
    if (FLAG_SET_CMDLINE(bool, RequireSharedSpaces, true) != JVMFlag::SUCCESS) {
      return JNI_EINVAL;
    }
    LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(class, path));
  }

  // Change the default value for flags  which have different default values
  // when working with older JDKs.
  fix_appclasspath();

  return JNI_OK;
}
```



### 4.2 Arguments::finalize_vm_init_args方法

```c++
jint Arguments::finalize_vm_init_args(bool patch_mod_javabase) {

  char path[JVM_MAXPATHLEN];
  const char* fileSep = os::file_separator();
  //Arguments::get_java_home()返回 "_java_home->value()"; 
  //而关于"_java_home"字段的初始化参考《7. InitializeJVM 初始化JavaVM结构体信息.md》
  jio_snprintf(path, JVM_MAXPATHLEN, "%s%slib%sendorsed", Arguments::get_java_home(), fileSep, fileSep);

  // 检查是否存在 {_java_home}/lib/endorsed 目录; 
  // 因为jdk12不支持lib/endorsed, 所以如果存在此目录, 返回错误码
  DIR* dir = os::opendir(path);
  if (dir != NULL) {
    //打印错误信息, 略
    os::closedir(dir);
    return JNI_ERR;
  }

  // 检查${_java_home}/lib/ext目录是否存在, 因为jdk12同样不支持lib/ext
  jio_snprintf(path, JVM_MAXPATHLEN, "%s%slib%sext", Arguments::get_java_home(), fileSep, fileSep);
  dir = os::opendir(path);
  if (dir != NULL) {
    os::closedir(dir);
    return JNI_ERR;
  }

  if (AggressiveHeap) { //默认false
    // 下面是 set_aggressive_heap_flags() 方法的原英文翻译, 不太想继续展开了
    // This option inspects the machine and attempts to set various
    // parameters to be optimal for long-running, memory allocation
		// intensive jobs.  It is intended for machines with large
		// amounts of cpu and memory.
    jint result = set_aggressive_heap_flags();
    if (result != JNI_OK) {
      return result;
    }
  }

  // This must be done after all arguments have been processed.
  // java_compiler() true means set to "NONE" or empty.
  if (java_compiler() && !xdebug_mode()) {
    // For backwards compatibility, we switch to interpreted mode if
    // -Djava.compiler="NONE" or "" is specified AND "-Xdebug" was
    // not specified.
    set_mode_flags(_int);
  }

  // CompileThresholdScaling == 0.0 is same as -Xint: Disable compilation (enable interpreter-only mode),
  // but like -Xint, leave compilation thresholds unaffected.
  // With tiered compilation disabled, setting CompileThreshold to 0 disables compilation as well.
  if ((CompileThresholdScaling == 0.0) || (!TieredCompilation && CompileThreshold == 0)) {
    set_mode_flags(_int);
  }

  // eventually fix up InitialTenuringThreshold if only MaxTenuringThreshold is set
  if (FLAG_IS_DEFAULT(InitialTenuringThreshold) && (InitialTenuringThreshold > MaxTenuringThreshold)) {
    FLAG_SET_ERGO(uintx, InitialTenuringThreshold, MaxTenuringThreshold);
  }

  if (!check_vm_args_consistency()) {
    return JNI_ERR;
  }

#if INCLUDE_CDS
  if (DumpSharedSpaces) { //默认false
    // Disable biased locking now as it interferes with the clean up of
    // the archived Klasses and Java string objects (at dump time only).
    UseBiasedLocking = false;

    // Always verify non-system classes during CDS dump
    if (!BytecodeVerificationRemote) {
      BytecodeVerificationRemote = true;
      log_info(cds)("All non-system classes will be verified (-Xverify:remote) during CDS dump time.");
    }

    // Compilation is already disabled if the user specifies -Xshare:dump.
    // Disable compilation in case user specifies -XX:+DumpSharedSpaces instead of -Xshare:dump.
    set_mode_flags(_int);
  }
  if (UseSharedSpaces && patch_mod_javabase) {
    no_shared_spaces("CDS is disabled when " JAVA_BASE_NAME " module is patched.");
  }
  if (UseSharedSpaces && !DumpSharedSpaces && check_unsupported_cds_runtime_properties()) {
    FLAG_SET_DEFAULT(UseSharedSpaces, false);
  }
#endif

#ifndef CAN_SHOW_REGISTERS_ON_ASSERT
  UNSUPPORTED_OPTION(ShowRegistersOnAssert);
#endif // CAN_SHOW_REGISTERS_ON_ASSERT

  return JNI_OK;
}
```



## 5. set_object_alignment() 函数

> **源文件: arguments.cpp**
>
> **下面代码中的相关值: **
>
> **ObjectAlignmentInBytes: 8**
>
> **MinObjAlignmentInBytes: 8**
>
> **HeapWordSize: 8**
>
> **HeapWordsPerLong: 1**
>
> **MinObjAlignment: 1**
>
> **MinObjAlignmentInBytesMask: 7**

```c++
void set_object_alignment() {
  // Object alignment.
  assert(is_power_of_2(ObjectAlignmentInBytes), "ObjectAlignmentInBytes must be power of 2");
  MinObjAlignmentInBytes     = ObjectAlignmentInBytes; //8
  assert(MinObjAlignmentInBytes >= HeapWordsPerLong * HeapWordSize, 
         "ObjectAlignmentInBytes value is too small");
  MinObjAlignment            = MinObjAlignmentInBytes / HeapWordSize; //1
  assert(MinObjAlignmentInBytes == MinObjAlignment * HeapWordSize, "ObjectAlignmentInBytes value is incorrect");
  MinObjAlignmentInBytesMask = MinObjAlignmentInBytes - 1;

  LogMinObjAlignmentInBytes  = exact_log2(ObjectAlignmentInBytes); //3
  LogMinObjAlignment         = LogMinObjAlignmentInBytes - LogHeapWordSize; //0

  // Oop encoding heap max
  OopEncodingHeapMax = (uint64_t(max_juint) + 1) << LogMinObjAlignmentInBytes;

  if (SurvivorAlignmentInBytes == 0) {
    SurvivorAlignmentInBytes = ObjectAlignmentInBytes; //8
  }
}
```

