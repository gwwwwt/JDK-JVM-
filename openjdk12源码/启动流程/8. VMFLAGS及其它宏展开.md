# VM_FLAGS宏

> **源码: globals.hpp**
>
> **本Note主要以VM_FLAGS宏为例介绍宏展开的实现**

```c++
#define VM_FLAGS(develop,                                                   \
                 develop_pd,                                                \
                 product,                                                   \
                 product_pd,                                                \
                 diagnostic,                                                \
                 diagnostic_pd,                                             \
                 experimental,                                              \
                 notproduct,                                                \
                 manageable,                                                \
                 product_rw,                                                \
                 lp64_product,                                              \
                 range,                                                     \
                 constraint,                                                \
                 writeable)                                                 \
                                                                            \
  RUNTIME_FLAGS(                                                            \
    develop,                                                                \
    develop_pd,                                                             \
    product,                                                                \
    product_pd,                                                             \
    diagnostic,                                                             \
    diagnostic_pd,                                                          \
    experimental,                                                           \
    notproduct,                                                             \
    manageable,                                                             \
    product_rw,                                                             \
    lp64_product,                                                           \
    range,                                                                  \
    constraint,                                                             \
    writeable)                                                              \
                                                                            \
  GC_FLAGS(                                                                 \
    develop,                                                                \
    develop_pd,                                                             \
    product,                                                                \
    product_pd,                                                             \
    diagnostic,                                                             \
    diagnostic_pd,                                                          \
    experimental,                                                           \
    notproduct,                                                             \
    manageable,                                                             \
    product_rw,                                                             \
    lp64_product,                                                           \
    range,                                                                  \
    constraint,                                                             \
    writeable)                                                              \
```



## 1. 应用示例

> **在`JVMFlagRangeList::init`方法中， 包含如下部分代码，用到了`VM_FLAGS宏`。并且在方法中的其它部分中，还用到了包括`ARCH_FLAGS宏`、`JVMCI_FLAGS宏`等其它宏展开，这里以`VM_FLAGS宏`为例进行说明。**

```c++
//jvmFlagRangeList.cpp
emit_range_no(NULL VM_FLAGS(EMIT_RANGE_DEVELOPER_FLAG,
                              EMIT_RANGE_PD_DEVELOPER_FLAG,
                              EMIT_RANGE_PRODUCT_FLAG,
                              EMIT_RANGE_PD_PRODUCT_FLAG,
                              EMIT_RANGE_DIAGNOSTIC_FLAG,
                              EMIT_RANGE_PD_DIAGNOSTIC_FLAG,
                              EMIT_RANGE_EXPERIMENTAL_FLAG,
                              EMIT_RANGE_NOTPRODUCT_FLAG,
                              EMIT_RANGE_MANAGEABLE_FLAG,
                              EMIT_RANGE_PRODUCT_RW_FLAG,
                              EMIT_RANGE_LP64_PRODUCT_FLAG,
                              EMIT_RANGE_CHECK,
                              IGNORE_CONSTRAINT,
                              IGNORE_WRITEABLE));
```



### 1.1 EMIT_RANGE_DEVELOPER_FLAG宏

> **上面VM_FLAGS宏第一个参数传入了`EMIT_RANGE_DEVELOPER_FLAG`，定义如下：**

```c++
//jvmFlagRangeList.cpp
#define EMIT_RANGE_DEVELOPER_FLAG(type, name, value, doc)    ); emit_range_##type(#name,&name
```



## 2. RUNTIME_FLAGS宏

> **`VM_FLAGS宏`定义中涉及到了另外两个宏：`RUNTIME_FLAGS`和`GC_FLAGS`**
>
> **下面对`RUNTIME_FLAGS宏`进行说明**

```c++
//globals.hpp
#define RUNTIME_FLAGS(develop, \  
                      develop_pd, \
                      product, \
                      product_pd, \
                      diagnostic, \
                      diagnostic_pd, \
                      experimental, \
                      notproduct, \
                      manageable, \
                      product_rw, \
                      lp64_product, \
                      range, \
                      constraint, \
                      writeable) \
                                                                            \
  lp64_product(bool, UseCompressedOops, false,                              \
          "Use 32-bit object references in 64-bit VM. "                     \
          "lp64_product means flag is always constant in 32 bit VM")        \
                                                                            \
  lp64_product(bool, UseCompressedClassPointers, false,                     \
          "Use 32-bit class pointers in 64-bit VM. "                        \
          "lp64_product means flag is always constant in 32 bit VM")        \
                                                                            \
  notproduct(bool, CheckCompressedOops, true,                               \
          "Generate checks in encoding/decoding code in debug VM")          \
                                                                            \
  product(uintx, HeapSearchSteps, 3 PPC64_ONLY(+17),                        \
          "Heap allocation steps through preferred address regions to find" \
          " where it can allocate the heap. Number of steps to take per "   \
          "region.")                                                        \
          range(1, max_uintx)                                               \
                                                                            \
  lp64_product(intx, ObjectAlignmentInBytes, 8,                             \
          "Default object alignment in bytes, 8 is minimum")                \
          range(8, 256)                                                     \
          constraint(ObjectAlignmentInBytesConstraintFunc,AtParse)          \
                                                                            \
  develop(bool, CleanChunkPoolAsync, true,                                  \
          "Clean the chunk pool asynchronously")                            \
                                                                            \
  product_pd(bool, ThreadLocalHandshakes,                                   \
          "Use thread-local polls instead of global poll for safepoints.")  \
          constraint(ThreadLocalHandshakesConstraintFunc,AfterErgo)         \
                                                                            \
  diagnostic(uint, HandshakeTimeout, 0,                                     \
          "If nonzero set a timeout in milliseconds for handshakes")        \
                                                                            \
  experimental(bool, AlwaysSafeConstructors, false,                         \
          "Force safe construction, as if all fields are final.")           \
  //... 下面还有很多, 略        
```



### 2.1 develop宏展开示例

```c++
//上面RUNTIME_FLAGS宏的第一个参数为 develop
//而在展开时变换为:
develop(bool, CleanChunkPoolAsync, true, "Clean the chunk pool asynchronously") 
  
//对于VM_FLAGS宏, 它是将第一个参数直接传给RUNTIME_FLAGS宏, 
//结合第1节中的示例应用, 
VM_FLAGS(EMIT_RANGE_DEVELOPER_FLAG, //...
         
//所以对于示例代码, develop参数就是 EMIT_RANGE_DEVELOPER_FLAG
//而EMIT_RANGE_DEVELOPER_FLAG的定义为:
#define EMIT_RANGE_DEVELOPER_FLAG(type, name, value, doc)    ); emit_range_##type(#name,&name
         
//所以EMIT_RANGE_DEVELOPER_FLAG宏=>VM_FLAGS宏参数=>RUNTIME_FLAGS宏参数=>develop宏展开 的结果为:
); emit_range_bool("CleanChunkPoolAsync", &CleanChunkPoolAsync
```



### 2.2 EMIT_RANGE_DEVELOPER_FLAG宏的说明

> **根据下面的说明: `VM_FLAGS需要用括号()包围起来`**

```c++
/*
为什么EMIT_RANGE_DEVELOPER_FLAG要展开为 "); emit_range_##type(#name, &name" 这种奇怪的格式;

把第1节中的示例 emit_range_no 简化后, 大概可以理解:
其中 NULL 为空
*/
emit_range_no(NULL VM_FLAGS(EMIT_RANGE_DEVELOPER_FLAG));

/*
会替换为: 
emit_range_no(); emit_range_bool("CleanChunkPoolAsync", &CleanChunkPoolAsync);
*/
```



## 3. GC_FLAGS

> **源码: gc_globals.hpp**
>
> **基本实现可以参考上面RUNTIME_FLAGS宏的实现，只是更加复杂**

```c++
#define GC_FLAGS(develop,                                                   \
                 develop_pd,                                                \
                 product,                                                   \
                 product_pd,                                                \
                 diagnostic,                                                \
                 diagnostic_pd,                                             \
                 experimental,                                              \
                 notproduct,                                                \
                 manageable,                                                \
                 product_rw,                                                \
                 lp64_product,                                              \
                 range,                                                     \
                 constraint,                                                \
                 writeable)                                                 \
                 
  CMSGC_ONLY(GC_CMS_FLAGS(                                                  \
    develop,                                                                \
    develop_pd,                                                             \
    product,                          
    //...
    ))
  EPSILONGC_ONLY(GC_EPSILON_FLAGS(                                          \
    develop,                                                                \
    develop_pd,          
    //...
    ))
  G1GC_ONLY(GC_G1_FLAGS(                                                    \
    develop,                                                                \
    develop_pd,                                                             \
    product,                                                                \
    //...
    ))
  PARALLELGC_ONLY(GC_PARALLEL_FLAGS(                                        \
    develop,                                                                \
    develop_pd,                                                             \
    product,                                                                \
    //...
    ))
  SERIALGC_ONLY(GC_SERIAL_FLAGS(                                            \
    develop,                                                                \
    develop_pd,                                                             \
    product,                                                                \
    //...
    ))
 SHENANDOAHGC_ONLY(GC_SHENANDOAH_FLAGS(                                    \
    develop,                                                                \
    develop_pd,                                                             \
    product,                                                                \
    //...
    ))
 ZGC_ONLY(GC_Z_FLAGS(                                                      \
    develop,                                                                \
    develop_pd,                                                             \
    //...                 
    ))
  product(bool, UseConcMarkSweepGC, false,                                  \
          "Use Concurrent Mark-Sweep GC in the old generation")             \
                                                                            \
  product(bool, UseSerialGC, false,                                         \
          "Use the Serial garbage collector")                               \
                                                                            \
  product(bool, UseG1GC, false,                                             \
          "Use the Garbage-First garbage collector")                        \
                                                                            \
  product(bool, UseParallelGC, false,                                       \
          "Use the Parallel Scavenge garbage collector")                    \
                                                                            \
  product(bool, UseParallelOldGC, false,                                    \
          "Use the Parallel Old garbage collector")                         \
                                                                            \
  experimental(bool, UseEpsilonGC, false,                                   \
          "Use the Epsilon (no-op) garbage collector")                      \
  //.... 还有很多
```



### 3.1 GC_Z_FLAGS

> **源码: z_globals.hpp**

```c++
#define GC_Z_FLAGS(develop,                                                 \
                   develop_pd,                                              \
                   product,                                                 \
                   product_pd,                                              \
                   diagnostic,                                              \
                   diagnostic_pd,                                           \
                   experimental,                                            \
                   notproduct,                                              \
                   manageable,                                              \
                   product_rw,                                              \
                   lp64_product,                                            \
                   range,                                                   \
                   constraint,                                              \
                   writeable)                                               \
                                                                            \
  product(ccstr, ZPath, NULL,                                               \
          "Filesystem path for Java heap backing storage "                  \
          "(must be a tmpfs or a hugetlbfs filesystem)")                    \
                                                                            \
  product(double, ZAllocationSpikeTolerance, 2.0,                           \
          "Allocation spike tolerance factor")                              \
                                                                            \
  product(double, ZFragmentationLimit, 25.0,                                \
          "Maximum allowed heap fragmentation")                             \
                                                                            \
  product(bool, ZStallOnOutOfMemory, true,                                  \
          "Allow Java threads to stall and wait for GC to complete "        \
          "instead of immediately throwing an OutOfMemoryError")            \
                                                                            \
  product(size_t, ZMarkStackSpaceLimit, 8*G,                                \
          "Maximum number of bytes allocated for mark stacks")              \
          range(32*M, 1024*G)                                               \
                                                                            \
  product(uint, ZCollectionInterval, 0,                                     \
          "Force GC at a fixed time interval (in seconds)")                 \
                                                                            \
  product(uint, ZStatisticsInterval, 10,                                    \
          "Time between statistics print outs (in seconds)")                \
          range(1, (uint)-1)                                                \
                                                                            \
  diagnostic(bool, ZStatisticsForceTrace, false,                            \
          "Force tracing of ZStats")                                        \
                                                                            \
  diagnostic(bool, ZProactive, true,                                        \
          "Enable proactive GC cycles")                                     \
                                                                            \
  diagnostic(bool, ZUnmapBadViews, false,                                   \
          "Unmap bad (inactive) heap views")                                \
                                                                            \
  diagnostic(bool, ZVerifyMarking, false,                                   \
          "Verify marking stacks")                                          \
                                                                            \
  diagnostic(bool, ZVerifyForwarding, false,                                \
          "Verify forwarding tables")                                       \
                                                                            \
  diagnostic(bool, ZOptimizeLoadBarriers, true,                             \
          "Apply load barrier optimizations")                               \
                                                                            \
  develop(bool, ZVerifyLoadBarriers, false,                                 \
          "Verify that reference loads are followed by barriers")

#endif // SHARE_GC_Z_Z_GLOBALS_HPP
```



# 自定义实现

```c++
#define VM_FLAGS(develop,                                                   \
                 develop_pd,                                                \
                 product,                                                   \
                 product_pd,                                                \
                 diagnostic,   
                 /...
                 )
```

> **对于要实现自定义的VM_FLAGS，参考它的参数，需要自定义`develop`、`product`等宏参数的实现。**
>
> **`develop`等宏实现需要展开为自定义的函数或方法实现，即需要自定义`参数宏`和`参数宏调用的函数`两套代码。**
>
> **这样，VM_FLAGS这样的宏会自动展开为对`自定义函数`的调用。**
>
> > **注意: 由于`VM_FLAGS宏以及它调用的宏中规定了develop, product等宏的参数个数和类型`， 所以`自定义的函数也必须符合对应的宏中的参数个数和格式，否则会报错`。**
> >
> > **另外，`VM_FLAGS宏`中预定义了所有可能的VM标志，但可能本模块或函数中并不需要处理所有标志，则`可以将对应的函数定义为空实现，而只实现预期的标志或参数`。**
> >
> > **以第1节的`JVMFlagRangeList::init`实现为例，由于JVMFlagRangeList中不想处理bool型数据，所以它将展开后的bool型函数`emit_range_bool()`定义为空实现，这样就可以跳过对bool类型数据的处理。另外由于想要处理数值型数据，所以对于`emit_range_intx`函数中则包含了特定的实现逻辑。**



# 各种不同的宏包含的参数的标志位类型

> **VM_FLAGS: VM相关标志**
>
> **ARCH_FLAGS: 硬件相关标志**
>
> **JVMCI_FLAGS: JVMCI相关**
>
> **C1_FLAGS: C1级别编译器标志**
>
> **C2_FLAGS: C2级别编译器标志**