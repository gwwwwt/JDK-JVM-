# InitializeJVM 函数

> **源码: java.c**

```c
/*
作用: 
1. 初始化 Java Virtual Machine(用JavaVM结构体表示)
2. 初始化完成后释放options数组
*/
static jboolean InitializeJVM(JavaVM **pvm, JNIEnv **penv, InvocationFunctions *ifn)
{
    JavaVMInitArgs args;
    jint r;

    //用从命令行解析的JVM参数信息填充args结构体
    memset(&args, 0, sizeof(args));
    args.version  = JNI_VERSION_1_2;
    args.nOptions = numOptions;
    args.options  = options;
    args.ignoreUnrecognized = JNI_FALSE;

    if (JLI_IsTraceLauncher()) { //log
        int i = 0;
        printf("JavaVM args:\n    ");
        printf("version 0x%08lx, ", (long)args.version);
        printf("ignoreUnrecognized is %s, ",
               args.ignoreUnrecognized ? "JNI_TRUE" : "JNI_FALSE");
        printf("nOptions is %ld\n", (long)args.nOptions);
        for (i = 0; i < numOptions; i++)
            printf("    option[%2d] = '%s'\n",
                   i, args.options[i].optionString);
    }

    //主要调用了ifn->CreateJavaVM函数指针来完成创建JVM的工作
    r = ifn->CreateJavaVM(pvm, (void **)penv, &args);
    JLI_MemFree(options);
    return r == JNI_OK;
}
```



## 1. JNI_CreateJavaVM函数

> **"ifn->CreateJavaVM"指向的就是`JNI_CreateJavaVM`函数**
>
> **源码: jni.cpp**

```c++
_JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_CreateJavaVM(JavaVM **vm, void **penv, void *args) {
  jint result = JNI_ERR;
  result = JNI_CreateJavaVM_inner(vm, penv, args); //主要调用函数
  return result;
}
```



## 2. JNI_CreateJavaVM_inner函数

> **重要的函数调用: Threads::create_vm**

```c++
static jint JNI_CreateJavaVM_inner(JavaVM **vm, void **penv, void *args) {
  
  HOTSPOT_JNI_CREATEJAVAVM_ENTRY((void **) vm, penv, args); //略

  jint result = JNI_ERR;
  DT_RETURN_MARK(CreateJavaVM, jint, (const jint&)result); //略

  // 原英文注释: 下面的逻辑会用Atomic::xchg实现同步. 有些 Zero platforms使用
  // GCC内嵌的 __sync_lock_test_and_test来实现Atomic::xchg. 但是不同的平台
  // 对该指令的支持不同, 所以下面的 #if 主要是测试Atomic::xchg能否实现期望的功能
  /*
  Atomic::xchg(v1, p)方法大概逻辑是原子的实现如下序列:
  	{
  		v2 = *p; //取指针目标的原值
  		*p = v1; //将指针目标的值更新为参数
  		return v2; //返回原指针目标值
  	}
  */
#if defined(ZERO) && defined(ASSERT)
  {
    jint a = 0xcafebabe;
    //结果: b: 0xcafebabe; a: 0xdeadbeef 
    jint b = Atomic::xchg((jint) 0xdeadbeef, &a);
    void *c = &a;
    //结果: c: &b; d: &a
    void *d = Atomic::xchg(&b, &c);
    assert(a == (jint) 0xdeadbeef && b == (jint) 0xcafebabe, "Atomic::xchg() works");
    assert(c == &b && d == &a, "Atomic::xchg() works");
  }
#endif // ZERO && ASSERT

  //将vm_created设置为1, 如果 vm_created 之前已经是1, 直接退出
  if (Atomic::xchg(1, &vm_created) == 1) {
    return JNI_EEXIST;   
  }
  //将safe_to_recreate_vm更新为0, 如果它的值之前已经是0, 直接退出
  if (Atomic::xchg(0, &safe_to_recreate_vm) == 0) {
    return JNI_ERR; 
  }
  assert(vm_created == 1, "vm_created is true during the creation");

  /*
  成员变量作用, 原项注释: 如果在初始化过程中发生了一些特定错误的话, 并不会报错, 而是
  隔一段时间之后再尝试执行; 但是如果发生了重要错误的话, 可以将can_try_again设置为false,
  从而阻止再次执行初始化工作
  */
  bool can_try_again = true;

  // --- ***核心调用***, 参考第3节
  result = Threads::create_vm((JavaVMInitArgs*) args, &can_try_again);
  
  if (result == JNI_OK) {
    JavaThread *thread = JavaThread::current();
    assert(!thread->has_pending_exception(), "should have returned not OK");
    /* thread is thread_in_vm here */
    *vm = (JavaVM *)(&main_vm);
    *(JNIEnv**)penv = thread->jni_environment();

#if INCLUDE_JVMCI
    if (EnableJVMCI) {
      if (UseJVMCICompiler) {
        // JVMCI is initialized on a CompilerThread
        if (BootstrapJVMCI) {
          JavaThread* THREAD = thread;
          JVMCICompiler* compiler = JVMCICompiler::instance(true, CATCH);
          compiler->bootstrap(THREAD);
          if (HAS_PENDING_EXCEPTION) {
            HandleMark hm;
            vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
          }
        }
      }
    }
#endif

    // Tracks the time application was running before GC
    RuntimeService::record_application_start();

    // Notify JVMTI
    if (JvmtiExport::should_post_thread_life()) {
       JvmtiExport::post_thread_start(thread);
    }

    post_thread_start_event(thread);

#ifndef PRODUCT
    if (ReplayCompiles) ciReplay::replay(thread);

    // Some platforms (like Win*) need a wrapper around these test
    // functions in order to properly handle error conditions.
    VMError::test_error_handler();
#endif

    // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving.
    ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native);
  } else {
    // If create_vm exits because of a pending exception, exit with that
    // exception.  In the future when we figure out how to reclaim memory,
    // we may be able to exit with JNI_ERR and allow the calling application
    // to continue.
    if (Universe::is_fully_initialized()) {
      // otherwise no pending exception possible - VM will already have aborted
      JavaThread* THREAD = JavaThread::current();
      if (HAS_PENDING_EXCEPTION) {
        HandleMark hm;
        vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
      }
    }

    if (can_try_again) {
      // reset safe_to_recreate_vm to 1 so that retrial would be possible
      safe_to_recreate_vm = 1;
    }

    // Creation failed. We must reset vm_created
    *vm = 0;
    *(JNIEnv**)penv = 0;
    // reset vm_created last to avoid race condition. Use OrderAccess to
    // control both compiler and architectural-based reordering.
    OrderAccess::release_store(&vm_created, 0);
  }

  // Flush stdout and stderr before exit.
  fflush(stdout);
  fflush(stderr);

  return result;

}
```



## 3. Threads::create_vm

> **源码: thread.cpp**

```c++
jint Threads::create_vm(JavaVMInitArgs* args, bool* canTryAgain) {
  
  extern void JDK_Version_init(); //--- 参考3.1节

  // VM初始化前的准备工作, 默认空实现
  VM_Version::early_initialize();

  //版本检查, 在InitializeJVM方法中构造args参数时, version传入的JNI_VERSION_1.2
  if (!is_supported_jni_version(args->version)) return JNI_EVERSION;

  // Initialize library-based TLS, --- 参考3.2节
  ThreadLocalStorage::init(); //用于存储线程本地Thread

  ostream_init(); // Initialize the output stream module

  // Process java launcher properties. --- 参考3.3节
  Arguments::process_sun_java_launcher_properties(args);

  // Initialize the os module. --- 参考3.4节
  // 本方法主要初始化一些硬件、线程、条件/互斥对象的初始化
  // 下面还会调用另一个os初始化方法, os::init_2()
  os::init();

  // Record VM creation timing statistics
  TraceVmCreationTime create_vm_timer;
  create_vm_timer.start();

  // Initialize system properties. --- 参考3.5节
  Arguments::init_system_properties();

  JDK_Version_init(); //调用3.1节extern导入的函数声明
  
  // --- 上面初始化jdk version后, 将jvm version信息加入Arguments#_system_properties中
  // 参考3.6节
  Arguments::init_version_specific_system_properties();

  // 初始化Log相关配置
  LogConfiguration::initialize(create_vm_timer.begin_time());

  // --- 参考3.7节; 将多种来源的参数选项解析到Arguments的对应字段中
  // --- ***重要: 解析所有配置options***; 方法内部调用了os::init_container_support()
  jint parse_result = Arguments::parse(args);
  if (parse_result != JNI_OK) return parse_result;

  os::init_before_ergo(); //3.8节

  jint ergo_result = Arguments::apply_ergo();//3.9节
  if (ergo_result != JNI_OK) return ergo_result;

  // Final check of all ranges after ergonomics which may change values.
  if (!JVMFlagRangeList::check_ranges()) {
    return JNI_EINVAL;
  }

  // Final check of all 'AfterErgo' constraints after ergonomics which may change values.
  bool constraint_result = JVMFlagConstraintList::check_constraints(JVMFlagConstraint::AfterErgo);
  if (!constraint_result) {
    return JNI_EINVAL;
  }

  JVMFlagWriteableList::mark_startup();

  if (PauseAtStartup) {
    os::pause();
  }

  HOTSPOT_VM_INIT_BEGIN();

  // Timing (must come after argument parsing)
  TraceTime timer("Create VM", TRACETIME_LOG(Info, startuptime));

  // Initialize the os module after parsing the args
  jint os_init_2_result = os::init_2();
  if (os_init_2_result != JNI_OK) return os_init_2_result;

  SafepointMechanism::initialize();

  jint adjust_after_os_result = Arguments::adjust_after_os();
  if (adjust_after_os_result != JNI_OK) return adjust_after_os_result;

  // Initialize output stream logging
  ostream_init_log();

  // Convert -Xrun to -agentlib: if there is no JVM_OnLoad
  // Must be before create_vm_init_agents()
  if (Arguments::init_libraries_at_startup()) {
    convert_vm_init_libraries_to_agents();
  }

  // Launch -agentlib/-agentpath and converted -Xrun agents
  if (Arguments::init_agents_at_startup()) {
    create_vm_init_agents();
  }

  // Initialize Threads state
  _thread_list = NULL;
  _number_of_threads = 0;
  _number_of_non_daemon_threads = 0;

  // Initialize global data structures and create system classes in heap
  vm_init_globals();

#if INCLUDE_JVMCI
  if (JVMCICounterSize > 0) {
    JavaThread::_jvmci_old_thread_counters = NEW_C_HEAP_ARRAY(jlong, JVMCICounterSize, mtInternal);
    memset(JavaThread::_jvmci_old_thread_counters, 0, sizeof(jlong) * JVMCICounterSize);
  } else {
    JavaThread::_jvmci_old_thread_counters = NULL;
  }
#endif // INCLUDE_JVMCI

  // Attach the main thread to this os thread
  JavaThread* main_thread = new JavaThread();
  main_thread->set_thread_state(_thread_in_vm);
  main_thread->initialize_thread_current();
  // must do this before set_active_handles
  main_thread->record_stack_base_and_size();
  main_thread->register_thread_stack_with_NMT();
  main_thread->set_active_handles(JNIHandleBlock::allocate_block());

  if (!main_thread->set_as_starting_thread()) {
    vm_shutdown_during_initialization(
                                      "Failed necessary internal allocation. Out of swap space");
    main_thread->smr_delete();
    *canTryAgain = false; // don't let caller call JNI_CreateJavaVM again
    return JNI_ENOMEM;
  }

  // Enable guard page *after* os::create_main_thread(), otherwise it would
  // crash Linux VM, see notes in os_linux.cpp.
  main_thread->create_stack_guard_pages();

  // Initialize Java-Level synchronization subsystem
  ObjectMonitor::Initialize();

  // Initialize global modules
  jint status = init_globals();
  if (status != JNI_OK) {
    main_thread->smr_delete();
    *canTryAgain = false; // don't let caller call JNI_CreateJavaVM again
    return status;
  }

  JFR_ONLY(Jfr::on_vm_init();)

  // Should be done after the heap is fully created
  main_thread->cache_global_variables();

  HandleMark hm;

  { MutexLocker mu(Threads_lock);
    Threads::add(main_thread);
  }

  // Any JVMTI raw monitors entered in onload will transition into
  // real raw monitor. VM is setup enough here for raw monitor enter.
  JvmtiExport::transition_pending_onload_raw_monitors();

  // Create the VMThread
  { TraceTime timer("Start VMThread", TRACETIME_LOG(Info, startuptime));

  VMThread::create();
    Thread* vmthread = VMThread::vm_thread();

    if (!os::create_thread(vmthread, os::vm_thread)) {
      vm_exit_during_initialization("Cannot create VM thread. "
                                    "Out of system resources.");
    }

    // Wait for the VM thread to become ready, and VMThread::run to initialize
    // Monitors can have spurious returns, must always check another state flag
    {
      MutexLocker ml(Notify_lock);
      os::start_thread(vmthread);
      while (vmthread->active_handles() == NULL) {
        Notify_lock->wait();
      }
    }
  }

  assert(Universe::is_fully_initialized(), "not initialized");
  if (VerifyDuringStartup) {
    // Make sure we're starting with a clean slate.
    VM_Verify verify_op;
    VMThread::execute(&verify_op);
  }

  // We need this to update the java.vm.info property in case any flags used
  // to initially define it have been changed. This is needed for both CDS and
  // AOT, since UseSharedSpaces and UseAOT may be changed after java.vm.info
  // is initially computed. See Abstract_VM_Version::vm_info_string().
  // This update must happen before we initialize the java classes, but
  // after any initialization logic that might modify the flags.
  Arguments::update_vm_info_property(VM_Version::vm_info_string());

  Thread* THREAD = Thread::current();

  // Always call even when there are not JVMTI environments yet, since environments
  // may be attached late and JVMTI must track phases of VM execution
  JvmtiExport::enter_early_start_phase();

  // Notify JVMTI agents that VM has started (JNI is up) - nop if no agents.
  JvmtiExport::post_early_vm_start();

  initialize_java_lang_classes(main_thread, CHECK_JNI_ERR);

  quicken_jni_functions();

  // No more stub generation allowed after that point.
  StubCodeDesc::freeze();

  // Set flag that basic initialization has completed. Used by exceptions and various
  // debug stuff, that does not work until all basic classes have been initialized.
  set_init_completed();

  LogConfiguration::post_initialize();
  Metaspace::post_initialize();

  HOTSPOT_VM_INIT_END();

  // record VM initialization completion time
#if INCLUDE_MANAGEMENT
  Management::record_vm_init_completed();
#endif // INCLUDE_MANAGEMENT

  // Signal Dispatcher needs to be started before VMInit event is posted
  os::initialize_jdk_signal_support(CHECK_JNI_ERR);

  // Start Attach Listener if +StartAttachListener or it can't be started lazily
  if (!DisableAttachMechanism) {
    AttachListener::vm_start();
    if (StartAttachListener || AttachListener::init_at_startup()) {
      AttachListener::init();
    }
  }

  // Launch -Xrun agents
  // Must be done in the JVMTI live phase so that for backward compatibility the JDWP
  // back-end can launch with -Xdebug -Xrunjdwp.
  if (!EagerXrunInit && Arguments::init_libraries_at_startup()) {
    create_vm_init_libraries();
  }

  if (CleanChunkPoolAsync) {
    Chunk::start_chunk_pool_cleaner_task();
  }

  // initialize compiler(s)
#if defined(COMPILER1) || COMPILER2_OR_JVMCI
#if INCLUDE_JVMCI
  bool force_JVMCI_intialization = false;
  if (EnableJVMCI) {
    // Initialize JVMCI eagerly when it is explicitly requested.
    // Or when JVMCIPrintProperties is enabled.
    // The JVMCI Java initialization code will read this flag and
    // do the printing if it's set.
    force_JVMCI_intialization = EagerJVMCI || JVMCIPrintProperties;

    if (!force_JVMCI_intialization) {
      // 8145270: Force initialization of JVMCI runtime otherwise requests for blocking
      // compilations via JVMCI will not actually block until JVMCI is initialized.
      force_JVMCI_intialization = UseJVMCICompiler && (!UseInterpreter || !BackgroundCompilation);
    }
  }
#endif
  CompileBroker::compilation_init_phase1(CHECK_JNI_ERR);
  // Postpone completion of compiler initialization to after JVMCI
  // is initialized to avoid timeouts of blocking compilations.
  if (JVMCI_ONLY(!force_JVMCI_intialization) NOT_JVMCI(true)) {
    CompileBroker::compilation_init_phase2();
  }
#endif

  // Pre-initialize some JSR292 core classes to avoid deadlock during class loading.
  // It is done after compilers are initialized, because otherwise compilations of
  // signature polymorphic MH intrinsics can be missed
  // (see SystemDictionary::find_method_handle_intrinsic).
  initialize_jsr292_core_classes(CHECK_JNI_ERR);

  // This will initialize the module system.  Only java.base classes can be
  // loaded until phase 2 completes
  call_initPhase2(CHECK_JNI_ERR);

  // Always call even when there are not JVMTI environments yet, since environments
  // may be attached late and JVMTI must track phases of VM execution
  JvmtiExport::enter_start_phase();

  // Notify JVMTI agents that VM has started (JNI is up) - nop if no agents.
  JvmtiExport::post_vm_start();

  // Final system initialization including security manager and system class loader
  call_initPhase3(CHECK_JNI_ERR);

  // cache the system and platform class loaders
  SystemDictionary::compute_java_loaders(CHECK_JNI_ERR);

#if INCLUDE_CDS
  if (DumpSharedSpaces) {
    // capture the module path info from the ModuleEntryTable
    ClassLoader::initialize_module_path(THREAD);
  }
#endif

#if INCLUDE_JVMCI
  if (force_JVMCI_intialization) {
    JVMCIRuntime::force_initialization(CHECK_JNI_ERR);
    CompileBroker::compilation_init_phase2();
  }
#endif

  // Always call even when there are not JVMTI environments yet, since environments
  // may be attached late and JVMTI must track phases of VM execution
  JvmtiExport::enter_live_phase();

  // Make perfmemory accessible
  PerfMemory::set_accessible(true);

  // Notify JVMTI agents that VM initialization is complete - nop if no agents.
  JvmtiExport::post_vm_initialized();

  JFR_ONLY(Jfr::on_vm_start();)

#if INCLUDE_MANAGEMENT
  Management::initialize(THREAD);

  if (HAS_PENDING_EXCEPTION) {
    // management agent fails to start possibly due to
    // configuration problem and is responsible for printing
    // stack trace if appropriate. Simply exit VM.
    vm_exit(1);
  }
#endif // INCLUDE_MANAGEMENT

  if (MemProfiling)                   MemProfiler::engage();
  StatSampler::engage();
  if (CheckJNICalls)                  JniPeriodicChecker::engage();

  BiasedLocking::init();

#if INCLUDE_RTM_OPT
  RTMLockingCounters::init();
#endif

  if (JDK_Version::current().post_vm_init_hook_enabled()) {
    call_postVMInitHook(THREAD);
    // The Java side of PostVMInitHook.run must deal with all
    // exceptions and provide means of diagnosis.
    if (HAS_PENDING_EXCEPTION) {
      CLEAR_PENDING_EXCEPTION;
    }
  }

  {
    MutexLocker ml(PeriodicTask_lock);
    // Make sure the WatcherThread can be started by WatcherThread::start()
    // or by dynamic enrollment.
    WatcherThread::make_startable();
    // Start up the WatcherThread if there are any periodic tasks
    // NOTE:  All PeriodicTasks should be registered by now. If they
    //   aren't, late joiners might appear to start slowly (we might
    //   take a while to process their first tick).
    if (PeriodicTask::num_tasks() > 0) {
      WatcherThread::start();
    }
  }

  create_vm_timer.end();
#ifdef ASSERT
  _vm_complete = true;
#endif

  if (DumpSharedSpaces) {
    MetaspaceShared::preload_and_dump(CHECK_JNI_ERR);
    ShouldNotReachHere();
  }

  return JNI_OK;
}
```



### 3.1 JDK_Version_init() 函数

> **参考：《2. jdk version初始化.md》**



### 3.2 ThreadLocalStorage::init()

> **初始化ThreadLocalStorage，初始化`static pthread_key_t _thread_key`，参考《3. 线程本地存储.md》**



### 3.3 Arguments::process_sun_java_launcher_properties()方法

> **源文件：arguments.cpp**
>
> **凡是涉及到调用Arguments的处理options逻辑的话，大部分都是转化到Arguments的特定字段值 **
>
> **本方法遍历命令行options，可能会影响到的字段为: **
>
> **`_sun_java_launcher`、`_sun_java_launcher_is_altjvm`、`_sun_java_launcher_pid`**

```c++
// 解析命令行获取 Launcher相关JVM options
void Arguments::process_sun_java_launcher_properties(JavaVMInitArgs* args) {
  
  //必须先处理Launcher option, 因为后面初始化VM时可能会用来这些option
  for (int index = 0; index < args->nOptions; index++) {
    const JavaVMOption* option = args->options + index;
    const char* tail;

    //参考《1. 入口.md》, tail = "SUN_STANDARD"
    if (match_option(option, "-Dsun.java.launcher=", &tail)) {
      //设置 _sun_java_launcher = "SUN_STANDARD"
      process_java_launcher_argument(tail, option->extraInfo);
      continue;
    }
    
    //--- 默认是没有下面两个option的
    if (match_option(option, "-Dsun.java.launcher.is_altjvm=", &tail)) {
      if (strcmp(tail, "true") == 0) {
        _sun_java_launcher_is_altjvm = true;
      }
      continue;
    }
    if (match_option(option, "-Dsun.java.launcher.pid=", &tail)) {
      _sun_java_launcher_pid = atoi(tail);
      continue;
    }
  }
}
```



### 3.4 os::init()

> **源文件: os_bsd.cpp**
>
> **作用：硬件信息、线程信息、时间函数、线程条件/同步对象初始化**

```c++
void os::init(void) { //需要在解析jvm options前调用本方法
  char dummy;   // used to get a guess on initial stack address

  // 在BsdThreads情况下, JavaMain Thread pid 和 java launcher thread是不同的;
  // 所以在Bsd系统中, launcher pid需要通过 -Dsun.java.launcher.pid传入;
  // 结合3.3节, 如果没有传入这个属性, 是不会初始化_sun_java_launcher_pid的;
  // 而此方法就是获取该变量的值, 所以默认情况下java_launcher_pid为0
  pid_t java_launcher_pid = (pid_t) Arguments::sun_java_launcher_pid();

  // 如果没有设置 _sun_java_launcher_pid变量, 则调用getpid()做为结果
  _initial_pid = (java_launcher_pid > 0) ? java_launcher_pid : getpid();

  clock_tics_per_sec = CLK_TCK;

  //os::_rand_seed = 1234567
  init_random(1234567);

  //getpagesize()为系统调用, 返回一个page中的字节数, 默认4096
  //Bsd::_page_size = 4096
  Bsd::set_page_size(getpagesize());

  //os::_page_sizes[0] = 4096
  //os::_page_sizes[1] = 0; //0值为哨兵
  init_page_sizes((size_t) Bsd::page_size());

  //sysctl系统调用获取本机cpu核心数, 设置到os::_processor_count中
  Bsd::initialize_system_info();

  // _main_thread points to the thread that created/loaded the JVM.
  Bsd::_main_thread = pthread_self(); //设置Bsd::_main_thread
 
  //时间相关
  Bsd::clock_init();
  initial_time_count = javaTimeNanos();

  os::Posix::init(); //方法调用, 初始化时间函数指针和pthread条件/同步对象
}
```



#### 3.4.1 os::Posix::init()方法

> **源码： os_posix.cpp**

```c++
// 当前系统支持哪些 POSIX API 并进行一些配置
// 本方法调用时没有logging支持, 会在init_2()中进行log
void os::Posix::init(void) {
  
  // 1. Check for CLOCK_MONOTONIC support.
  void* handle = RTLD_DEFAULT;
  
  // 初始化两个函数指针, 分别指向两个
  // _clock_gettime => clock_getres系统调用
  // _clock_getres  => clock_gettime系统调用
  _clock_gettime = NULL;
  _clock_getres = NULL;

  int (*clock_getres_func)(clockid_t, struct timespec*) =
    (int(*)(clockid_t, struct timespec*))dlsym(handle, "clock_getres");
  int (*clock_gettime_func)(clockid_t, struct timespec*) =
    (int(*)(clockid_t, struct timespec*))dlsym(handle, "clock_gettime");
  
  if (clock_getres_func != NULL && clock_gettime_func != NULL) {
    struct timespec res;
    struct timespec tp;
    if (clock_getres_func(CLOCK_MONOTONIC, &res) == 0 &&
        clock_gettime_func(CLOCK_MONOTONIC, &tp) == 0) {
      
      _clock_gettime = clock_gettime_func;
      _clock_getres = clock_getres_func;
    } else {
    }
  }

  // 2. Check for pthread_condattr_setclock support.
  // 初始化 _pthread_condattr_setclock => pthread_condattr_setclock
  // 但是好像Mac没有这个系统调用
  _pthread_condattr_setclock = NULL;

  int (*condattr_setclock_func)(pthread_condattr_t*, clockid_t) =
    (int (*)(pthread_condattr_t*, clockid_t))dlsym(RTLD_DEFAULT,
                                                   "pthread_condattr_setclock");
  if (condattr_setclock_func != NULL) {
    _pthread_condattr_setclock = condattr_setclock_func;
  }

  // 3. 初始化上面的三个函数指针后, 初始化全局条件/互斥object
  pthread_init_common();

  // --- 有啥用???
  int status;
  if (_pthread_condattr_setclock != NULL && _clock_gettime != NULL) {
    if ((status = _pthread_condattr_setclock(_condAttr, CLOCK_MONOTONIC)) != 0) {
      if (status == EINVAL) {
        _use_clock_monotonic_condattr = false;
        warning("Unable to use monotonic clock with relative timed-waits" \
                " - changes to the time-of-day clock may have adverse affects");
      } else {
        fatal("pthread_condattr_setclock: %s", os::strerror(status));
      }
    } else {
      _use_clock_monotonic_condattr = true;
    }
  } else {
    _use_clock_monotonic_condattr = false;
  }
}

// --- os::Posix::pthread_init_common方法
/*
初始化的全局变量: 
static pthread_condattr_t _condAttr[1]; //条件object
static pthread_mutexattr_t _mutexAttr[1]; //互斥object
*/
static void pthread_init_common(void) {
  int status;
  if ((status = pthread_condattr_init(_condAttr)) != 0) {
    fatal("pthread_condattr_init: %s", os::strerror(status));
  }
  if ((status = pthread_mutexattr_init(_mutexAttr)) != 0) {
    fatal("pthread_mutexattr_init: %s", os::strerror(status));
  }
  if ((status = pthread_mutexattr_settype(_mutexAttr, PTHREAD_MUTEX_NORMAL)) != 0) {
    fatal("pthread_mutexattr_settype: %s", os::strerror(status));
  }
}
```



### 3.5 Arguments::init_system_properties()

> **函数作用: 初始化Arguments中的用于保存不同的path信息以及属性的成员变量，主要有如下几个字段**
>
> > **Arguments中定义了多个 (PathString\*) 或 (SystemProperty\*)类型的成员变量：**
> >
> > + **_system_boot_class_path：boot class path路径**
> > + **_vm_info：vm完整信息，这里只是初始化，需要等到解析参数后再补完**
> > + **\_sun_boot_library_path、\_java_library_path、\_java_home、\_java_class_path：需要等到调用os::init_system_properties_values()后补完**
> > + **_jdk_boot_class_path_append: 存储 -Xbootclasspath/a: 参数信息**
> > + **_system_properties：jvm版本、名字、调试级别等信息链表，上面的boot_class等也会append到这个链表上**

> **初始化上面的字段后，调用`os::init_system_properties_values()`填充上面的字段信息**

> **源码: arguments.cpp**
>
> > **key/value字符串由类SystemProperty包装，且SystemProperty除了包装key/value字符串外，还定义了`_internal` 和 `_writable`两个成员变量。类定义：**
> >
> > ```c++
> > class PathString : public CHeapObj<mtArguments> {
> > protected:
> > char* _value;
> > ...
> > }
> > 
> > class SystemProperty : public PathString {
> > private:
> > char*           _key;
> > SystemProperty* _next;
> > bool            _internal;
> > bool            _writeable;
> > ...
> > }
> > ```
> >
> > > **可以看到，\_value在父类PathString中定义，\_key在SystemProperty中定义。**
> > >
> > > **此外还有一个`_next`字段，所以多个SystemProperty可以构成一个单向链表。**
>

```c++
void Arguments::init_system_properties() {
  // --- 下面的XXX_path字段, 使用NULL来初始化
  // --- 初始化_system_properies链表, 并先往链表中添加了VM版本信息SystemProperty属性

  //--- SystemProperty构造方法的第3个参数 false/true 设置的是 _writeable字段
  //--- 第4个参数 false/true 设置的是 _internal字段
  PropertyList_add(&_system_properties, 
                   new SystemProperty("java.vm.specification.name",
                   				"Java Virtual Machine Specification",  false));
  
  //"12-internal+0-adhoc.gwwwwt.jdk12"
  PropertyList_add(&_system_properties, 
                   new SystemProperty("java.vm.version", VM_Version::vm_release(),  false));
  
  //"OpenJDK 64-Bit Server VM"
  PropertyList_add(&_system_properties, 
                   new SystemProperty("java.vm.name", VM_Version::vm_name(),  false));
  //"fastdebug"
  PropertyList_add(&_system_properties,
                   new SystemProperty("jdk.debug", VM_Version::jdk_debug_level(),  false));

  //""mixed mode, aot, sharing""
  _vm_info = new SystemProperty("java.vm.info", VM_Version::vm_info_string(), true);
  
  _system_boot_class_path = new PathString(NULL);

  // 下面几个是 JVMTI agent writable properties, 并且是os specific;
  // 它们的 _value初始化为NULL或"". 
  // 而具体的值填充是在下面的os::init_system_properties_values() 方法中完成的
  _sun_boot_library_path = new SystemProperty("sun.boot.library.path", NULL,  true);
  _java_library_path = new SystemProperty("java.library.path", NULL,  true);
  _java_home =  new SystemProperty("java.home", NULL,  true);
  _java_class_path = new SystemProperty("java.class.path", "",  true);
  
  // jdk.boot.class.path.append is a non-writeable, internal property.
  // It can only be set by either:
  //    - -Xbootclasspath/a:
  //    - AddToBootstrapClassLoaderSearch during JVMTI OnLoad phase
  _jdk_boot_class_path_append = new SystemProperty("jdk.boot.class.path.append", "", false, true);

  // Add to System Property list.
  PropertyList_add(&_system_properties, _sun_boot_library_path);
  PropertyList_add(&_system_properties, _java_library_path);
  PropertyList_add(&_system_properties, _java_home);
  PropertyList_add(&_system_properties, _java_class_path);
  PropertyList_add(&_system_properties, _jdk_boot_class_path_append);
  PropertyList_add(&_system_properties, _vm_info);

  // 根据共享库位置设置上面的_java_home、_sun_boot_library_path、_ext_dirs等信息
  os::init_system_properties_values();
}
```



#### 3.5.1 os::init_system_properties_values()

> **源码: os_bsd.cpp**
>
> **作用: os模块获取当前共享库的路径来填充Arguments中的相关字段信息**
>
> **经过调用后，影响到的Arguments字段值如下： **
>
> > **以本机MacOS为例，下面的路径前缀都是"/Users/gwwwwt/jvm/jdk12/build/macosx-x86_64-server-fastdebug/"**
> >
> > **Arguments::_sun_boot_library_path: `jdk/lib`**
> >
> > **Arguments::_java_home: `jdk`**
> >
> > **Arguments::_system_boot_class_path: `modules/java.base`**
> >
> > **Arguments::_has_jimage: false**
> >
> > **Arguments::_java_library_path:`/Users/gwwwwt/Library/Java/Extensions:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java:.`**
> >
> > **Arguments::_ext_dirs: `/Users/gwwwwt/Library/Java/Extensions:/Users/gwwwwt/jvm/jdk12/build/macosx-x86_64-server-fastdebug/jdk/lib/ext:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java`**

```c++
void os::init_system_properties_values() {
  /*
  在MacOS上,下面的libjvm.so需要换成libjvm.dylib
  本方法在product version jdk中主要有如下几步:
  1. 从 libjvm.so的完整路径获取 JAVA_HOME 值; 下面的os::jvm_path();
  	libjvm.so的路径应该是 <JAVA_HOME>/jre/lib/<arch>/{client|server}/libjvm.so
  2. 如果在libjvm.so路径中包含"jre/lib/"子字符串, 则认为libjvm.so路径正确
  	如果不包含"jre/lib/"子字符串, 则报错返回"Could not create the Java virtual machine."
  
  而在debugging version jdk中则主要是如下几步:
  1. 接上面product version中的第2步, 如果libjvm.so路径不包含"jre/lib",
  	并不会退出, 而是检查"$JAVA_HOME"环境变量
  2. 如果定义了"$JAVA_HOME", 并且可以定位 $JAVAH_HOME/jre/lib/<arch>,
  	则附加 "hotspot/libjvm.so"到这个path, 则检查libjvm.so路径是否存在:
  	<JAVA_HOME>/jre/lib/<arch>/hotspot/libjvm.so
  3. 检查不通过直接退出
  */
#ifndef DEFAULT_LIBPATH
  #ifndef OVERRIDE_LIBPATH
    #define DEFAULT_LIBPATH "/lib:/usr/lib"
  #endif
#endif

// Base path of extensions installed on the system.
#define SYS_EXT_DIR     "/usr/java/packages"
#define EXTENSIONS_DIR  "/lib/ext"

#ifndef __APPLE__
// 非Mac环境逻辑略
#else // __APPLE__

  #define SYS_EXTENSIONS_DIR   "/Library/Java/Extensions"
  #define SYS_EXTENSIONS_DIRS  SYS_EXTENSIONS_DIR ":/Network" SYS_EXTENSIONS_DIR ":/System" SYS_EXTENSIONS_DIR ":/usr/lib/java"

  const char *user_home_dir = get_home(); //获取用户home目录, 在本机Mac上返回NULL, 

  size_t system_ext_size = strlen(user_home_dir) + sizeof(SYS_EXTENSIONS_DIR) +
    sizeof(SYS_EXTENSIONS_DIRS);

  const size_t bufsize =
    MAX2((size_t)MAXPATHLEN,  // for dll_dir & friends.
         (size_t)MAXPATHLEN + sizeof(EXTENSIONS_DIR) + system_ext_size); // extensions dir
  char *buf = (char *)NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);

  { //--- 设置Arguments::_sun_boot_library_path
    //--- 设置Arguments::_java_home
    char *pslash;
    //参考下面3.5.1.1节, jvm_path返回后, buf数组中的内容为:
    ///Users/gwwwwt/jvm/jdk12/build/macosx-x86_64-server-fastdebug/jdk/lib/server/libjvm.dylib
    os::jvm_path(buf, bufsize);

    // 通过pslash将buf中的路径截断到如下字符串:
    //"/Users/gwwwwt/jvm/jdk12/build/macosx-x86_64-server-fastdebug/jdk/lib"
    // 即buf中的路径也是上面这个字符串
    *(strrchr(buf, '/')) = '\0'; // Get rid of /libjvm.so.
    pslash = strrchr(buf, '/');
    if (pslash != NULL) {
      *pslash = '\0';            // Get rid of /{client|server|hotspot}.
    }

    // --- 1. 设置 _sun_boot_library_path#_value 字段为".../jdk/lib"
    Arguments::set_dll_dir(buf);

    // --- 2. 设置 _java_home#_value 字段为 ".../jdk"
    if (pslash != NULL) {
      pslash = strrchr(buf, '/');
      if (pslash != NULL) {
        *pslash = '\0';          // Get rid of /lib.
      }
    }
    Arguments::set_java_home(buf);
    
    //设置Arguments::_system_boot_class_path: modules/java.base
    set_boot_path('/', ':'); 
  }

  { //--- 设置Arguments::_java_library_path
    const char *l = ::getenv("JAVA_LIBRARY_PATH");
    const char *l_colon = ":";
    if (l == NULL) { l = ""; l_colon = ""; }

    const char *v = ::getenv("DYLD_LIBRARY_PATH");
    const char *v_colon = ":";
    if (v == NULL) { v = ""; v_colon = ""; }

    char *ld_library_path = (char *)NEW_C_HEAP_ARRAY(char,
                                                     strlen(v) + 1 + strlen(l) + 1 +
                                                     system_ext_size + 3,
                                                     mtInternal);
    sprintf(ld_library_path, "%s%s%s%s%s" SYS_EXTENSIONS_DIR ":" SYS_EXTENSIONS_DIRS ":.",
            v, v_colon, l, l_colon, user_home_dir);
    /*
    设置_java_library_path#_value字段为:
"/Users/gwwwwt/Library/Java/Extensions:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java:."
    */
    Arguments::set_library_path(ld_library_path);
    FREE_C_HEAP_ARRAY(char, ld_library_path);
  }

  /*
  设置Arguments::_ext_dirs为: 
  "/Users/gwwwwt/Library/Java/Extensions:/Users/gwwwwt/jvm/jdk12/build/macosx-x86_64-server-fastdebug/jdk/lib/ext:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java"
  */
  sprintf(buf, "%s" SYS_EXTENSIONS_DIR ":%s" EXTENSIONS_DIR ":" SYS_EXTENSIONS_DIRS,
          user_home_dir, Arguments::get_java_home());
  Arguments::set_ext_dirs(buf);

  FREE_C_HEAP_ARRAY(char, buf);
#undef SYS_EXTENSIONS_DIR
#undef SYS_EXTENSIONS_DIRS
#endif // __APPLE__
#undef SYS_EXT_DIR
#undef EXTENSIONS_DIR
}
```



##### 3.5.1.1 os::jvm_path()方法

> **源码: os_bsd.cpp**
>
> **本机返回路径："/Users/gwwwwt/jvm/jdk12/build/macosx-x86_64-server-fastdebug/jdk/lib/server/libjvm.dylib"**

```c++
void os::jvm_path(char *buf, jint buflen) { // 获取libjvm.so或libjvm.dylib的路径
  // 如果全局变量 char saved_jvm_path[]的第一个字符非, 认为已初始化
  // 则直接复制 saved_jvm_path内容即可
  if (saved_jvm_path[0] != 0) {
    strcpy(buf, saved_jvm_path);
    return;
  }

  // dladdr系统调用, 获取os::jvm_path方法指针所在的共享库路径;
  // 也就是 libjvm.[so,dylib]的路径,保存在dli_fname数组中
  char dli_fname[MAXPATHLEN];
  bool ret = dll_address_to_library_name(
                                         CAST_FROM_FN_PTR(address, os::jvm_path),
                                         dli_fname, sizeof(dli_fname), NULL);
  assert(ret, "cannot locate libjvm");
  char *rp = NULL;
  if (ret && dli_fname[0] != '\0') {
    rp = os::Posix::realpath(dli_fname, buf, buflen);
  }
  if (rp == NULL) {
    return;
  }

  //--- 下面if条件默认false, 略过
  if (Arguments::sun_java_launcher_is_altjvm()) {
    // Support for the java launcher's '-XXaltjvm=<path>' option. Typical
    // value for buf is "<JAVA_HOME>/jre/lib/<arch>/<vmtype>/libjvm.so"
    // or "<JAVA_HOME>/jre/lib/<vmtype>/libjvm.dylib". If "/jre/lib/"
    // appears at the right place in the string, then assume we are
    // installed in a JDK and we're done. Otherwise, check for a
    // JAVA_HOME environment variable and construct a path to the JVM
    // being overridden.

    const char *p = buf + strlen(buf) - 1;
    for (int count = 0; p > buf && count < 5; ++count) {
      for (--p; p > buf && *p != '/'; --p)
        /* empty */ ;
    }
    if (strncmp(p, "/jre/lib/", 9) != 0) {
      char* java_home_var = ::getenv("JAVA_HOME");
      if (java_home_var != NULL && java_home_var[0] != 0) {
        char* jrelib_p;
        int len;

        p = strrchr(buf, '/');
        assert(strstr(p, "/libjvm") == p, "invalid library name");

        rp = os::Posix::realpath(java_home_var, buf, buflen);
        if (rp == NULL) {
          return;
        }

        len = strlen(buf);
        assert(len < buflen, "Ran out of buffer space");
        jrelib_p = buf + len;

        snprintf(jrelib_p, buflen-len, "/jre/lib");
        if (0 != access(buf, F_OK)) {
          snprintf(jrelib_p, buflen-len, "/lib");
        }

        len = strlen(buf);
        jrelib_p = buf + len;
        snprintf(jrelib_p, buflen-len, "/%s", COMPILER_VARIANT);
        if (0 != access(buf, F_OK)) {
          snprintf(jrelib_p, buflen-len, "%s", "");
        }

        if (0 == access(buf, F_OK)) {
          len = strlen(buf);
          snprintf(buf + len, buflen-len, "/libjvm%s", JNI_LIB_SUFFIX);
        } else {
          rp = os::Posix::realpath(dli_fname, buf, buflen);
          if (rp == NULL) {
            return;
          }
        }
      }
    }
  }

  //saved_jvm_path包含了libjvm共享库路径
  strncpy(saved_jvm_path, buf, MAXPATHLEN);
  saved_jvm_path[MAXPATHLEN - 1] = '\0';
}
```



### 3.6 Arguments::init_version_specific_system_properties() 方法

> **源码: arguments.cpp**
>
> **作用:  本方法的调用顺序排在`JDK_Version_init();`之后，所以本方法的作用就是将`JDK_Version::_current`中保存的JDK 版本信息也保存到`_system_properties链表`**

```c++
// Update/Initialize System properties after JDK version number is known
void Arguments::init_version_specific_system_properties() {
  enum { bufsz = 16 };
  char buffer[bufsz];
  const char* spec_vendor = "Oracle Corporation";
  uint32_t spec_version = JDK_Version::current().major_version(); //12

  jio_snprintf(buffer, bufsz, UINT32_FORMAT, spec_version); //12

  //"Oracle Corporation"
  PropertyList_add(&_system_properties,
      new SystemProperty("java.vm.specification.vendor",  spec_vendor, false));
  
  //"12"
  PropertyList_add(&_system_properties,
      new SystemProperty("java.vm.specification.version", buffer, false));
  
  //"Oracle Corporation"
  PropertyList_add(&_system_properties,
      new SystemProperty("java.vm.vendor", VM_Version::vm_vendor(),  false));
}
```



### 3.7 Arguments::parse() 方法 

> **参考《9. 解析Options参数 Arguments::parse.md》**



### 3.8 os::init_before_ergo() 方法

> **主要设置JavaThread 线程栈大小**

```c++
void os::init_before_ergo() {
  //os._initial_active_processor_count = os._processor_count
  //os._processor_count字段在 3.4节 os::init() 中初始化
  initialize_initial_active_processor_count();
  
  large_page_init(); //MacOS空方法体

  // 设置JavaThread的相关字段值; 它们需要在 os::init_2()中进行设置最小栈大小 之前设置
  // vm_age_size() 返回os::Bsd::page_size(); 它同样是在 3.4节 os::init()中初始化的, 一般为4k
  // StackRedPages: 1; StackYellowPages: 2; StackReservedPages: 1; StackShadowPages: 20
  JavaThread::set_stack_red_zone_size     (align_up(StackRedPages      * 4 * K, vm_page_size()));
  JavaThread::set_stack_yellow_zone_size  (align_up(StackYellowPages   * 4 * K, vm_page_size()));
  JavaThread::set_stack_reserved_zone_size(align_up(StackReservedPages * 4 * K, vm_page_size()));
  JavaThread::set_stack_shadow_zone_size  (align_up(StackShadowPages   * 4 * K, vm_page_size()));

  // VM version initialization identifies some characteristics of the
  // platform that are used during ergonomic decisions.
  VM_Version::init_before_ergo(); //空实现
}
```



### 3.9 Arguments::apply_ergo() 方法

```c++
jint Arguments::apply_ergo() {
  // Set flags based on ergonomics.
  jint result = set_ergonomics_flags();
  if (result != JNI_OK) return result;

  // Set heap size based on available physical memory
  set_heap_size();

  GCConfig::arguments()->initialize();

  set_shared_spaces_flags();

  // Initialize Metaspace flags and alignments
  Metaspace::ergo_initialize();

  // Set compiler flags after GC is selected and GC specific
  // flags (LoopStripMiningIter) are set.
  CompilerConfig::ergo_initialize();

  // Set bytecode rewriting flags
  set_bytecode_flags();

  // Set flags if aggressive optimization flags are enabled
  jint code = set_aggressive_opts_flags();
  if (code != JNI_OK) {
    return code;
  }

  // Turn off biased locking for locking debug mode flags,
  // which are subtly different from each other but neither works with
  // biased locking
  if (UseHeavyMonitors
#ifdef COMPILER1
      || !UseFastLocking
#endif // COMPILER1
#if INCLUDE_JVMCI
      || !JVMCIUseFastLocking
#endif
    ) {
    if (!FLAG_IS_DEFAULT(UseBiasedLocking) && UseBiasedLocking) {
      // flag set to true on command line; warn the user that they
      // can't enable biased locking here
      warning("Biased Locking is not supported with locking debug flags"
              "; ignoring UseBiasedLocking flag." );
    }
    UseBiasedLocking = false;
  }

#ifdef CC_INTERP
  // Clear flags not supported on zero.
  FLAG_SET_DEFAULT(ProfileInterpreter, false);
  FLAG_SET_DEFAULT(UseBiasedLocking, false);
  LP64_ONLY(FLAG_SET_DEFAULT(UseCompressedOops, false));
  LP64_ONLY(FLAG_SET_DEFAULT(UseCompressedClassPointers, false));
#endif // CC_INTERP

  if (PrintAssembly && FLAG_IS_DEFAULT(DebugNonSafepoints)) {
    warning("PrintAssembly is enabled; turning on DebugNonSafepoints to gain additional output");
    DebugNonSafepoints = true;
  }

  if (FLAG_IS_CMDLINE(CompressedClassSpaceSize) && !UseCompressedClassPointers) {
    warning("Setting CompressedClassSpaceSize has no effect when compressed class pointers are not used");
  }

#ifndef PRODUCT
  if (!LogVMOutput && FLAG_IS_DEFAULT(LogVMOutput)) {
    if (use_vm_log()) {
      LogVMOutput = true;
    }
  }
#endif // PRODUCT

  if (PrintCommandLineFlags) {
    JVMFlag::printSetFlags(tty);
  }

  // Apply CPU specific policy for the BiasedLocking
  if (UseBiasedLocking) {
    if (!VM_Version::use_biased_locking() &&
        !(FLAG_IS_CMDLINE(UseBiasedLocking))) {
      UseBiasedLocking = false;
    }
  }
#ifdef COMPILER2
  if (!UseBiasedLocking) {
    UseOptoBiasInlining = false;
  }
#endif

#if defined(IA32)
  // Only server compiler can optimize safepoints well enough.
  if (!is_server_compilation_mode_vm()) {
    FLAG_SET_ERGO_IF_DEFAULT(bool, ThreadLocalHandshakes, false);
  }
#endif

  // ThreadLocalHandshakesConstraintFunc handles the constraints.
  if (FLAG_IS_DEFAULT(ThreadLocalHandshakes) || !SafepointMechanism::supports_thread_local_poll()) {
    log_debug(ergo)("ThreadLocalHandshakes %s", ThreadLocalHandshakes ? "enabled." : "disabled.");
  } else {
    log_info(ergo)("ThreadLocalHandshakes %s", ThreadLocalHandshakes ? "enabled." : "disabled.");
  }

  return JNI_OK;
}
```



#### 3.9.1 Arguments::set_ergonomics_flags() 方法

```c++
jint Arguments::set_ergonomics_flags() {
  GCConfig::initialize();

  set_conservative_max_heap_alignment();

#ifndef ZERO
#ifdef _LP64
  set_use_compressed_oops();

  // set_use_compressed_klass_ptrs() must be called after calling
  // set_use_compressed_oops().
  set_use_compressed_klass_ptrs();

  // Also checks that certain machines are slower with compressed oops
  // in vm_version initialization code.
#endif // _LP64
#endif // !ZERO

  return JNI_OK;
}

// ---GCConfig.cpp
//---- 初始化可用GC列表
void GCConfig::initialize() {
  assert(_arguments == NULL, "Already initialized");
  _arguments = select_gc();
}

GCArguments* GCConfig::select_gc() {
  // Fail immediately if an unsupported GC is selected
  fail_if_unsupported_gc_is_selected();

  /*
  is_no_gc_selected() 会检查GCConfig.cpp中定义的静态变量:
  static const SupportedGC SupportedGCs[] = {
   SupportedGC(UseConcMarkSweepGC, CollectedHeap::CMS, cmsArguments, "concurrent mark sweep gc"),
   SupportedGC(UseEpsilonGC, CollectedHeap::Epsilon, epsilonArguments, "epsilon gc"),
   SupportedGC(UseG1GC, CollectedHeap::G1, g1Arguments, "g1 gc"),
   SupportedGC(UseParallelGC, CollectedHeap::Parallel, parallelArguments, "parallel gc"),
   SupportedGC(UseParallelOldGC, CollectedHeap::Parallel, parallelArguments, "parallel gc"),
   SupportedGC(UseSerialGC, CollectedHeap::Serial, serialArguments, "serial gc"),
   SupportedGC(UseShenandoahGC, CollectedHeap::Shenandoah, shenandoahArguments, "shenandoah gc"),
   SupportedGC(UseZGC, CollectedHeap::Z, zArguments, "z gc") };

  数组中的每个 SupportedGC对象的 _flags字段, 即上面构造方法的第一个参数; 
  初始时所有变量值均为false
  */
  if (is_no_gc_selected()) {
    // 对于MacOS+openjdk12环境, 设置 UseG1GC = true;
    // 即采用 G1 收集器
    select_gc_ergonomically(); 

    
    
    if (is_no_gc_selected()) {
      // Failed to select GC ergonomically
      vm_exit_during_initialization("Garbage collector not selected "
                                    "(default collector explicitly disabled)", NULL);
    }

    // Succeeded to select GC ergonomically
    _gc_selected_ergonomically = true;
  }

  if (!is_exactly_one_gc_selected()) {
    // More than one GC selected
    vm_exit_during_initialization("Multiple garbage collectors selected", NULL);
  }

  // Exactly one GC selected
  FOR_EACH_SUPPORTED_GC(gc) {
    if (gc->_flag) {
      return &gc->_arguments;
    }
  }

  fatal("Should have found the selected GC");

  return NULL;
}
```

